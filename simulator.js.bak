/**
 * CircuitSimulator v3.5 (Integrated)
 * ê¸°ëŠ¥: ë“œë˜ê·¸/ì¤Œ/íŒ¬, ì „ì„  ì—°ê²°, ë¡œì§ ì‹œë®¬ë ˆì´ì…˜
 * ê³ ê¸‰: ìš°í´ë¦­ ë©”ë‰´, ë‹¤ì¤‘ ì„ íƒ, ë³µì‚¬/ë¶™ì—¬ë„£ê¸°, ë‹¨ì¶•í‚¤ ì„¤ì •, í•€ ì¤‘ì•™ ì •ë ¬
 * ì¶”ê°€: í”„ë¡œì íŠ¸ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ëŠ¥ (localStorage), ë‹¤êµ­ì–´ ì§€ì›, ëª¨ë‹¬ UI
 */

const TRANSLATIONS = {
    ko: {
        component: "âš¡ ë¶€í’ˆ",
        save: "ğŸ’¾ ì €ì¥",
        exit: "ğŸšª ë‚˜ê°€ê¸°",
        edit: "ğŸ‘† í¸ì§‘",
        pan: "âœ‹ ì´ë™",
        zoomIn: "ğŸ” í™•ëŒ€",
        zoomOut: "ğŸ” ì¶•ì†Œ",
        shortcut: "âš™ï¸ ë‹¨ì¶•í‚¤ ì„¤ì •",
        inputOutput: "ì…ë ¥ / ì¶œë ¥",
        logicGates: "ë…¼ë¦¬ ê²Œì´íŠ¸",
        settings: "ì„¤ì •",
        modeEasy: "ğŸ“ ëª¨ë“œ: ì´ì§€ (Easy)",
        modeExpert: "ğŸ”§ ëª¨ë“œ: ì „ë¬¸ê°€ (Expert)",
        expertAlert: "ì „ë¬¸ê°€ ëª¨ë“œ í™œì„±í™”!\në¶€í’ˆì„ ë”ë¸” í´ë¦­í•˜ì—¬ ì§€ì—° ì‹œê°„ê³¼ íŠ¸ëœì§€ìŠ¤í„° ìˆ˜ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        easyAlert: "ì´ì§€ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.",
        saveAlert: "í”„ë¡œì íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!",
        shortcutSaved: "ë‹¨ì¶•í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!",
        copy: "ë³µì‚¬",
        paste: "ë¶™ì—¬ë„£ê¸°",
        delete: "ì‚­ì œ",
        descSwitch: 'í´ë¦­í•˜ì—¬ ON/OFFë¥¼ ì „í™˜í•˜ëŠ” ì…ë ¥ ìŠ¤ìœ„ì¹˜ì…ë‹ˆë‹¤.',
        descLed: 'ì „ê¸°ê°€ íë¥´ë©´ ë¶ˆì´ ì¼œì§€ëŠ” ì¶œë ¥ ì¥ì¹˜ì…ë‹ˆë‹¤.',
        descClock: '1ì´ˆë§ˆë‹¤ ì‹ í˜¸ê°€ ë°”ë€ŒëŠ” í„ìŠ¤ ìƒì„±ê¸°ì…ë‹ˆë‹¤.',
        descAnd: 'ëª¨ë“  ì…ë ¥ì´ 1ì¼ ë•Œë§Œ 1ì„ ì¶œë ¥í•©ë‹ˆë‹¤.',
        descOr: 'ì…ë ¥ ì¤‘ í•˜ë‚˜ë¼ë„ 1ì´ë©´ 1ì„ ì¶œë ¥í•©ë‹ˆë‹¤.',
        descNot: 'ì…ë ¥ ê°’ì„ ë°˜ëŒ€ë¡œ ë’¤ì§‘ìŠµë‹ˆë‹¤.',
        descXor: 'ì…ë ¥ ê°’ì´ ì„œë¡œ ë‹¤ë¥¼ ë•Œë§Œ 1ì„ ì¶œë ¥í•©ë‹ˆë‹¤.',
        descNand: 'AND ê²Œì´íŠ¸ì˜ ë°˜ëŒ€ì…ë‹ˆë‹¤. ëª¨ë“  ì…ë ¥ì´ 1ì¼ ë•Œë§Œ 0ì„ ì¶œë ¥í•©ë‹ˆë‹¤.',
        descNor: 'OR ê²Œì´íŠ¸ì˜ ë°˜ëŒ€ì…ë‹ˆë‹¤. ì…ë ¥ ì¤‘ í•˜ë‚˜ë¼ë„ 1ì´ë©´ 0ì„ ì¶œë ¥í•©ë‹ˆë‹¤.',
        descXnor: 'XOR ê²Œì´íŠ¸ì˜ ë°˜ëŒ€ì…ë‹ˆë‹¤. ì…ë ¥ ê°’ì´ ì„œë¡œ ê°™ì„ ë•Œ 1ì„ ì¶œë ¥í•©ë‹ˆë‹¤.',
        // Gate Names
        gateAnd: "AND ê²Œì´íŠ¸",
        gateOr: "OR ê²Œì´íŠ¸",
        gateNot: "NOT ê²Œì´íŠ¸",
        gateXor: "XOR ê²Œì´íŠ¸",
        gateNand: "NAND ê²Œì´íŠ¸",
        gateNor: "NOR ê²Œì´íŠ¸",
        gateXnor: "XNOR ê²Œì´íŠ¸",
        gateSwitch: "ìŠ¤ìœ„ì¹˜",
        gateLed: "LED ì „êµ¬",
        gateClock: "í´ëŸ­ (í„ìŠ¤)",
        gateTr: "NPN íŠ¸ëœì§€ìŠ¤í„°",
        gatePmos: "PMOS íŠ¸ëœì§€ìŠ¤í„°",
        gateVcc: "VCC (ì „ì›)",
        gateGnd: "GND (ì ‘ì§€)",
        compLib: "ğŸ“š ë¶€í’ˆ ë¼ì´ë¸ŒëŸ¬ë¦¬"
    },
    en: {
        component: "âš¡ Components",
        save: "ğŸ’¾ Save",
        exit: "ğŸšª Exit",
        edit: "ğŸ‘† Edit",
        pan: "âœ‹ Pan",
        zoomIn: "ğŸ” Zoom In",
        zoomOut: "ğŸ” Zoom Out",
        shortcut: "âš™ï¸ Shortcuts",
        inputOutput: "Input / Output",
        logicGates: "Logic Gates",
        settings: "Settings",
        modeEasy: "ğŸ“ Mode: Easy",
        modeExpert: "ğŸ”§ Mode: Expert",
        expertAlert: "Expert Mode Enabled!\nDouble-click components to edit Delay and Transistors.",
        easyAlert: "Switched to Easy Mode.",
        saveAlert: "Project Saved!",
        shortcutSaved: "Shortcuts Saved!",
        copy: "Copy",
        paste: "Paste",
        delete: "Delete",
        descSwitch: 'A switch that toggles ON/OFF when clicked.',
        descLed: 'Output device that lights up when powered.',
        descClock: 'Pulse generator that changes signal every second.',
        descAnd: 'Outputs 1 only if all inputs are 1.',
        descOr: 'Outputs 1 if at least one input is 1.',
        descNot: 'Inverts the input value.',
        descXor: 'Outputs 1 only if inputs are different.',
        descNand: 'Opposite of AND. Outputs 0 only if all inputs are 1.',
        descNor: 'Opposite of OR. Outputs 0 if at least one input is 1.',
        descXnor: 'Opposite of XOR. Outputs 1 if inputs are same.',
        // Gate Names
        gateAnd: "AND Gate",
        gateOr: "OR Gate",
        gateNot: "NOT Gate",
        gateXor: "XOR Gate",
        gateNand: "NAND Gate",
        gateNor: "NOR Gate",
        gateXnor: "XNOR Gate",
        gateSwitch: "Switch",
        gateLed: "LED",
        gateClock: "Clock",
        gateTr: "NPN Transistor",
        gatePmos: "PMOS Transistor",
        gateVcc: "VCC (1)",
        gateGnd: "GND (0)",
        compLib: "ğŸ“š Component Library"
    },
    es: {
        component: "âš¡ Componentes",
        save: "ğŸ’¾ Guardar",
        exit: "ğŸšª Salir",
        edit: "ğŸ‘† Editar",
        pan: "âœ‹ Mover",
        zoomIn: "ğŸ” Acercar",
        zoomOut: "ğŸ” Alejar",
        shortcut: "âš™ï¸ Atajos",
        inputOutput: "Entrada / Salida",
        logicGates: "Puertas LÃ³gicas",
        settings: "Ajustes",
        modeEasy: "ğŸ“ Modo: FÃ¡cil",
        modeExpert: "ğŸ”§ Modo: Experto",
        expertAlert: "Â¡Modo Experto Activado!\nDoble clic en componentes para editar Retardo y Transistores.",
        easyAlert: "Cambiado a Modo FÃ¡cil.",
        saveAlert: "Â¡Proyecto Guardado!",
        shortcutSaved: "Â¡Atajos Guardados!",
        copy: "Copiar",
        paste: "Pegar",
        delete: "Eliminar",
        descSwitch: 'Un interruptor que cambia ON/OFF al hacer clic.',
        descLed: 'Dispositivo de salida que se ilumina con energÃ­a.',
        descClock: 'Generador de pulsos que cambia seÃ±al cada segundo.',
        descAnd: 'Salida 1 solo si todas las entradas son 1.',
        descOr: 'Salida 1 si al menos una entrada es 1.',
        descNot: 'Invierte el valor de entrada.',
        descXor: 'Salida 1 solo si las entradas son diferentes.',
        descNand: 'Opuesto a AND. Salida 0 solo si todas las entradas son 1.',
        descNor: 'Opuesto a OR. Salida 0 si al menos una entrada es 1.',
        descXnor: 'Opuesto a XOR. Salida 1 si las entradas son iguales.'
    }
};

// Global Error Handler for Debugging
window.onerror = function (msg, url, line, col, error) {
    // ì‚¬ìš©ì ì–¸ì–´ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
    const savedSettings = JSON.parse(localStorage.getItem('logic_sim_settings')) || {};
    const lang = savedSettings.language || 'ko';

    const errorMessages = {
        ko: {
            title: 'âš ï¸ ì‹œë®¬ë ˆì´í„° ì˜¤ë¥˜',
            line: 'ìœ„ì¹˜',
            message: 'ì˜¤ë¥˜ ë‚´ìš©',
            suggestion: 'í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê±°ë‚˜ ê°œë°œì ë„êµ¬ ì½˜ì†”(F12)ì„ í™•ì¸í•˜ì„¸ìš”.'
        },
        en: {
            title: 'âš ï¸ Simulator Error',
            line: 'Line',
            message: 'Error',
            suggestion: 'Please refresh the page or check the developer console (F12).'
        },
        es: {
            title: 'âš ï¸ Error del Simulador',
            line: 'LÃ­nea',
            message: 'Error',
            suggestion: 'Por favor, actualice la pÃ¡gina o revise la consola del desarrollador (F12).'
        }
    };

    const t = errorMessages[lang] || errorMessages.ko;

    console.error('Simulator Error:', { msg, url, line, col, error });

    alert(`${t.title}\n\n${t.line}: ${line}\n${t.message}: ${msg}\n\n${t.suggestion}`);

    return false;
};



const GATE_SCHEMATICS = {
    'AND': {
        parts: [
            { type: 'TRANSISTOR', x: 100, y: 100, id: 't1' }, // NMOS 1
            { type: 'TRANSISTOR', x: 200, y: 100, id: 't2' }, // NMOS 2
            { type: 'VCC', x: 50, y: 50, id: 'vcc' },
            { type: 'PORT_IN', x: 50, y: 100, label: 'A', id: 'in_1' },
            { type: 'PORT_IN', x: 150, y: 100, label: 'B', id: 'in_2' },
            { type: 'PORT_OUT', x: 300, y: 100, label: 'Out', id: 'out' }
        ],
        // Simple Series Logic (Pass Transistor Logic)
        wires: [
            { from: 'vcc.out', to: 't1.col' },
            { from: 'in_1.out', to: 't1.base' },
            { from: 't1.emit', to: 't2.col' },
            { from: 'in_2.out', to: 't2.base' },
            { from: 't2.emit', to: 'out.in' }
        ]
    },
    'OR': {
        parts: [
            { type: 'TRANSISTOR', x: 150, y: 50, id: 't1' },
            { type: 'TRANSISTOR', x: 150, y: 150, id: 't2' },
            { type: 'VCC', x: 50, y: 100, id: 'vcc' },
            { type: 'PORT_IN', x: 50, y: 50, label: 'A', id: 'in_1' },
            { type: 'PORT_IN', x: 50, y: 150, label: 'B', id: 'in_2' },
            { type: 'PORT_OUT', x: 300, y: 100, label: 'Out', id: 'out' }
        ],
        wires: [
            { from: 'vcc.out', to: 't1.col' },
            { from: 'vcc.out', to: 't2.col' },
            { from: 'in_1.out', to: 't1.base' },
            { from: 'in_2.out', to: 't2.base' },
            { from: 't1.emit', to: 'out.in' },
            { from: 't2.emit', to: 'out.in' }
        ]
    },
    'NOT': {
        parts: [
            { type: 'PMOS', x: 150, y: 100, id: 't1' },
            { type: 'VCC', x: 50, y: 50, id: 'vcc' },
            { type: 'GND', x: 150, y: 200, id: 'gnd' }, // Pull-down (Resistor-like or NMOS? Simplified)
            // Ideally CMOS needs NMOS pull-down too.
            // Let's implement full CMOS Inverter: PMOS (Top) + NMOS (Bottom)
            { type: 'TRANSISTOR', x: 150, y: 200, id: 't2' }, // NMOS
            { type: 'PORT_IN', x: 50, y: 150, label: 'In', id: 'in_1' },
            { type: 'PORT_OUT', x: 300, y: 150, label: 'Out', id: 'out' }
        ],
        wires: [
            // PMOS Source connected to VCC
            { from: 'vcc.out', to: 't1.col' }, // PMOS: col=Source, emit=Drain (simplified pin names)
            // NMOS Source (Emit) to GND (Wait, NMOS emit is output? standard NMOS: Drain->Source. Switch: Col->Emit)
            // Let's assume Col is High-side, Emit is Low-side.
            // NMOS: Col connected to Output, Emit connected to GND.
            { from: 'gnd.out', to: 't2.emit' },

            // Gates connected to Input
            { from: 'in_1.out', to: 't1.base' },
            { from: 'in_1.out', to: 't2.base' },

            // Drains connected to Output
            // PMOS Emit -> Out
            { from: 't1.emit', to: 'out.in' },
            // NMOS Col -> Out
            { from: 't2.col', to: 'out.in' }

            // Note: This matches CMOS Inverter topology.
            // PMOS (Top): on when Low. Passes VCC to Out.
            // NMOS (Bottom): on when High. Passes GND (Low) to Out?
            // Wait, NMOS Pass Logic: If Base=1, Col->Emit.
            // If we want to pull down to GND, we need GND at Col and connect Emit to Out? 
            // Or Col at Out and Emit at GND? If Base=1, current flows Col->Emit.
            // If Out is effectively Col, and GND is Emit. If Base=1, Out connects to GND. Yes.
        ]
    },
    'NAND': {
        parts: [
            { type: 'VCC', x: 150, y: 50, id: 'vcc' },
            { type: 'GND', x: 150, y: 300, id: 'gnd' },

            // Parallel PMOS (Pull-up)
            { type: 'PMOS', x: 100, y: 100, id: 'p1', label: 'P1' },
            { type: 'PMOS', x: 200, y: 100, id: 'p2', label: 'P2' },

            // Series NMOS (Pull-down)
            { type: 'TRANSISTOR', x: 150, y: 200, id: 'n1', label: 'N1' },
            { type: 'TRANSISTOR', x: 150, y: 250, id: 'n2', label: 'N2' },

            { type: 'PORT_IN', x: 50, y: 150, label: 'A', id: 'in_1' },
            { type: 'PORT_IN', x: 250, y: 150, label: 'B', id: 'in_2' },
            { type: 'PORT_OUT', x: 300, y: 200, label: 'Out', id: 'out' }
        ],
        wires: [
            // P1, P2 Sources to VCC
            { from: 'vcc.out', to: 'p1.col' },
            { from: 'vcc.out', to: 'p2.col' },

            // P1, P2 Drains to Output (and N1 Drain)
            { from: 'p1.emit', to: 'out.in' },
            { from: 'p2.emit', to: 'out.in' },
            { from: 'p1.emit', to: 'n1.col' }, // Connect Pull-up network to Pull-down network node

            // N1, N2 Series
            { from: 'n1.emit', to: 'n2.col' },
            { from: 'n2.emit', to: 'gnd.out' }, // N2 Source to GND

            // Inputs to Gates
            { from: 'in_1.out', to: 'p1.base' },
            { from: 'in_1.out', to: 'n1.base' },
            { from: 'in_2.out', to: 'p2.base' },
            { from: 'in_2.out', to: 'n2.base' }
        ]
    },
    'NOR': {
        parts: [
            { type: 'VCC', x: 150, y: 50, id: 'vcc' },
            { type: 'GND', x: 150, y: 300, id: 'gnd' },

            // Series PMOS (Pull-up)
            { type: 'PMOS', x: 150, y: 100, id: 'p1', label: 'P1' },
            { type: 'PMOS', x: 150, y: 150, id: 'p2', label: 'P2' },

            // Parallel NMOS (Pull-down)
            { type: 'TRANSISTOR', x: 100, y: 250, id: 'n1', label: 'N1' },
            { type: 'TRANSISTOR', x: 200, y: 250, id: 'n2', label: 'N2' },

            { type: 'PORT_IN', x: 50, y: 125, label: 'A', id: 'in_1' },
            { type: 'PORT_IN', x: 50, y: 225, label: 'B', id: 'in_2' },
            { type: 'PORT_OUT', x: 300, y: 200, label: 'Out', id: 'out' }
        ],
        wires: [
            // P1, P2 Series
            { from: 'vcc.out', to: 'p1.col' },
            { from: 'p1.emit', to: 'p2.col' },

            // P2 Drain to Output
            { from: 'p2.emit', to: 'out.in' },
            { from: 'p2.emit', to: 'n1.col' }, // Join Pull-up/Pull-down
            { from: 'p2.emit', to: 'n2.col' },

            // N1, N2 Parallel Drains (connected above)
            // N1, N2 Sources to GND
            { from: 'n1.emit', to: 'gnd.out' },
            { from: 'n2.emit', to: 'gnd.out' },

            // Inputs
            { from: 'in_1.out', to: 'p1.base' },
            { from: 'in_1.out', to: 'n1.base' },
            { from: 'in_2.out', to: 'p2.base' },
            { from: 'in_2.out', to: 'n2.base' }
        ]
    }
};

class CircuitSimulator {
    constructor() {
        // [Safety] Global Access
        window.sim = this;

        // [1] ì´ˆê¸°í™” ë° DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
        this.workspace = document.getElementById('workspace');
        this.wireLayer = document.getElementById('wire-layer');

        // Cache Main Workspace references
        this.mainWorkspace = this.workspace;
        this.mainWireLayer = this.wireLayer;

        // Internal Editor References
        this.internalModal = document.getElementById('internal-modal');
        this.internalWorkspace = document.getElementById('internal-workspace');
        this.internalWireLayer = document.getElementById('internal-wire-layer');
        this.internalTitle = document.getElementById('internal-title');

        this.tooltip = document.getElementById('tooltip');
        this.selectionBox = document.getElementById('selection-box');
        this.contextMenu = document.getElementById('context-menu');

        // [2] ìƒíƒœ ë³€ìˆ˜ë“¤
        this.components = []; // ìƒì„±ëœ ë¶€í’ˆ ëª©ë¡
        this.wires = [];      // ì—°ê²°ëœ ì „ì„  ëª©ë¡

        // Scope Stack for Sub-circuits
        this.scopeStack = []; // [{ components, wires, parentComp }]
        this.currentScopeComp = null; // The component whose internals we are viewing

        // íŒ¨í‚¤ì§€ ì‹œìŠ¤í…œ
        this.userPackages = []; // ì‚¬ìš©ì ì •ì˜ íŒ¨í‚¤ì§€ ì €ì¥

        // localStorageì—ì„œ ì‚¬ìš©ì íŒ¨í‚¤ì§€ ë¡œë“œ
        this.loadUserPackages();

        // Undo/Redo íˆìŠ¤í† ë¦¬
        this.history = [];
        this.historyIndex = -1;
        this.maxHistory = 50;

        // ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ
        this.isRunning = true;
        this.simulationSpeed = 100; // ms

        // ì¤Œ & íŒ¬ (í™”ë©´ ì´ë™/í™•ëŒ€)
        this.scale = 1.0;

        this.panX = 0;
        this.panY = 0;
        this.mode = 'edit';   // 'edit' ë˜ëŠ” 'pan'
        this.isPanning = false;

        // ë“œë˜ê·¸ & ì„ íƒ
        this.dragTarget = null;
        this.dragOffset = { x: 0, y: 0 };
        this.lastMouse = { x: 0, y: 0 };
        this.gridSize = 20;   // ê²©ì í¬ê¸° (Snap to Grid)

        // ë‹¤ì¤‘ ì„ íƒ & ë³µì‚¬/ë¶™ì—¬ë„£ê¸° ë³€ìˆ˜
        this.selectedComponents = [];
        this.clipboard = [];
        this.isSelecting = false;
        this.selectionStart = { x: 0, y: 0 };

        // ì™€ì´ì–´ë§ (ì „ì„  ì—°ê²°)
        this.startPin = null;
        this.tempLine = null;

        // í”„ë¡œì íŠ¸ ê´€ë¦¬
        this.currentProjectId = null;
        this.currentProjectName = 'Untitled Project';

        // [3] ë‹¨ì¶•í‚¤ ê¸°ë³¸ ì„¤ì • (ì»¤ìŠ¤í…€ ê°€ëŠ¥)
        this.shortcuts = {
            'A': 'AND', 'O': 'OR', 'N': 'NOT', 'X': 'XOR',
            'S': 'SWITCH', 'L': 'LED', 'C': 'CLOCK',
            'DELETE': 'DELETE', 'ESCAPE': 'ESCAPE'
        };

        // [4-1] ë‹¤êµ­ì–´ ì„¤ì • - ê³„ì • ì„¤ì •ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
        const savedSettings = JSON.parse(localStorage.getItem('logic_sim_settings')) || {};
        this.currentLang = savedSettings.language || 'ko';
        this.dict = TRANSLATIONS[this.currentLang] || TRANSLATIONS['ko'];
        this.showTutorialHints = savedSettings.showTutorials !== false;
        this.autoSave = savedSettings.autoSave !== false;

        // [4-2] ë¶€í’ˆ ì„¤ëª… ë°ì´í„° (ì–¸ì–´ë³„ ë™ì  ì²˜ë¦¬)
        this.descriptions = {}; // Placeholder - dynamic lookup used

        // [Mode State] - í†µí•© ëª¨ë“œ (ëª¨ë“  ê¸°ëŠ¥ í™œì„±í™”)
        this.userMode = 'expert'; // ëª¨ë“  ê¸°ëŠ¥ í•­ìƒ í™œì„±í™”

        // [Grid & Snap Settings]
        this.gridSnap = false; // ê·¸ë¦¬ë“œ ìŠ¤ëƒ… í™œì„±í™” ì—¬ë¶€
        this.gridSize = 20; // ê·¸ë¦¬ë“œ í¬ê¸° (px)
        this.wireMode = 'pin'; // 'pin' (ì†Œì í•€ ì§ì ‘ ì—°ê²°) or 'grid' (ê²©ì ê¸°ì¤€ ì—°ê²°)

        // [Simulation Settings]
        this.simulationSpeed = 1.0;

        // [Undo/Redo History System]
        this.history = [];
        this.historyIndex = -1;
        this.maxHistory = 50;  // Maximum undo steps

        // [5] ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        this.initEvents();

        // 1ì´ˆë§ˆë‹¤ Clock ì‘ë™ (í„ìŠ¤ ì‹ í˜¸) - Clock component specific tick
        setInterval(() => this.clockTick(), 1000);

        // [6] ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ ë° ë Œë” ë£¨í”„
        this.oscilloscope = new Oscilloscope(this);
        this.lastTime = 0;
        requestAnimationFrame((time) => this.loop(time));

        // í†µí•© ëª¨ë“œ: bodyì— expert-mode í´ë˜ìŠ¤ ì¶”ê°€í•˜ì—¬ ëª¨ë“  ìŠ¤íƒ€ì¼ í™œì„±í™”
        document.body.classList.add('expert-mode');

        // URL íŒŒë¼ë¯¸í„° í™•ì¸ ë° ë¡œë“œ
        this.initProject();
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        if (dt > 100) { // Limit oscilloscope update rate (~10fps is enough for simple graph)
            this.oscilloscope.update();
            this.oscilloscope.draw();
            this.lastTime = timestamp;
        }
        requestAnimationFrame((t) => this.loop(t));
    }

    // =========================================================
    // [Section 0] í”„ë¡œì íŠ¸ ì €ì¥ & ë¶ˆëŸ¬ì˜¤ê¸° (New)
    // =========================================================
    initProject() {
        const params = new URLSearchParams(window.location.search);
        const projectId = params.get('id');
        const isNew = params.get('new');

        // ê¸°ë³¸ ID ì„¤ì •
        if (projectId) {
            this.currentProjectId = projectId;
        } else {
            this.currentProjectId = 'temp_' + Date.now();
        }

        if (isNew === 'true') {
            // ìƒˆ í”„ë¡œì íŠ¸ ëª¨ë‹¬ ë„ìš°ê¸°
            const modal = document.getElementById('new-project-modal');
            if (modal) modal.classList.add('show');
        } else if (projectId) {
            // ê¸°ì¡´ í”„ë¡œì íŠ¸ ë¡œë“œ
            this.loadProject(projectId);
        }

        // ì´ˆê¸° ëª¨ë“œ ì„¤ì •
        this.setMode('edit');
        this.setUserMode('easy');
    }

    confirmNewProject() {
        // ëª¨ë‹¬ì—ì„œ ê°’ ê°€ì ¸ì˜¤ê¸° (null-safe)
        const nameInput = document.getElementById('new-proj-name');
        const modeInput = document.getElementById('new-proj-mode');
        const widthInput = document.getElementById('new-proj-width');
        const heightInput = document.getElementById('new-proj-height');

        const name = nameInput?.value?.trim() || "Untitled Project";
        const mode = modeInput?.value || 'easy';
        const w = widthInput ? parseInt(widthInput.value) || 3000 : 3000;
        const h = heightInput ? parseInt(heightInput.value) || 2000 : 2000;

        // 1. ëª¨ë“œ ì„¤ì •
        this.setUserMode(mode);
        if (mode === 'expert') {
            this.toggleUserMode(); // Expert ëª¨ë“œ UI í™œì„±í™”
            this.userMode = 'expert'; // ë‹¤ì‹œ ì„¤ì • (toggleì´ ë°˜ì „ì‹œí‚¤ë¯€ë¡œ)
        }

        // 2. ìº”ë²„ìŠ¤ ì‚¬ì´ì¦ˆ ì„¤ì • (ìˆìœ¼ë©´)
        if (typeof this.resizeCanvas === 'function') {
            this.resizeCanvas(w, h);
        }

        // 3. ì´ë¦„ ì„¤ì •
        this.currentProjectName = name;

        // 4. ëª¨ë‹¬ ë‹«ê¸°
        const modal = document.getElementById('new-project-modal');
        if (modal) modal.style.display = 'none';
    }

    // =========================================================
    // [Section 1] ë¶€í’ˆ(Module) ìƒì„± ë° ê´€ë¦¬
    // =========================================================
    addModule(type, x = null, y = null) {
        let el; // [FIX] try ë¸”ë¡ ë°–ì—ì„œ ì„ ì–¸í•˜ì—¬ return ê°€ëŠ¥í•˜ê²Œ
        try {
            el = document.createElement('div');
            el.classList.add('component');
            el.id = 'comp_' + Date.now() + Math.random().toString(36).substr(2, 5);
            el.setAttribute('data-type', type);
            el.setAttribute('data-value', '0');

            // Expert Mode Properties
            el.setAttribute('data-delay', '10'); // ms (simulation delay) - nominal
            el.setAttribute('data-transistors', this.getDefaultTransistors(type));

            // 1-1. ì´ë²¤íŠ¸ ì—°ê²°
            el.onmouseenter = () => this.showTooltip(type);
            el.onmouseleave = () => this.hideTooltip();

            // â˜… [NEW] Component Direct Click Handler
            el.onmousedown = (e) => this.handleComponentMouseDown(e, el);

            // â˜… ì¤‘ìš”: ìš°í´ë¦­ ì‹œ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í˜¸ì¶œ
            el.oncontextmenu = (e) => {
                e.preventDefault();
                e.stopPropagation();

                // JOINTì˜ ê²½ìš° ìš°í´ë¦­ ì‹œ "ì¶”ê°€ ì „ì„  ì—°ê²°" ê¸°ëŠ¥ (Expert Mode)
                if (type === 'JOINT' && this.userMode === 'expert') {
                    const pin = el.querySelector('.pin');
                    if (pin) {
                        this.handlePinClick(pin);
                        return;
                    }
                }

                // ìš°í´ë¦­í•œ ë¶€í’ˆë„ ì„ íƒ ìƒíƒœë¡œ ë§Œë“¦
                if (!this.selectedComponents.includes(el)) {
                    this.selectComponent(el, false);
                }
                this.showContextMenu(e.clientX, e.clientY);
            };

            // 1-2. ë¼ë²¨(ê¸€ì) ìƒì„±
            const label = document.createElement('div');
            label.classList.add('comp-label');
            el.appendChild(label);

            // 1-2-1. SVG ì‹¬ë³¼ ì‚½ì… (ANSI í‘œì¤€ + IO ì‹¬ë³¼)
            const symbols = {
                // Logic Gates - ANSI Standard (Pure schematic, no fill)
                'AND': `<svg viewBox="0 0 72 48"><path d="M12 8 L36 8 A 16 20 0 0 1 36 40 L12 40 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="12" y2="16" stroke="currentColor" stroke-width="2"/><line x1="0" y1="32" x2="12" y2="32" stroke="currentColor" stroke-width="2"/><line x1="52" y1="24" x2="72" y2="24" stroke="currentColor" stroke-width="2"/></svg>`,
                'OR': `<svg viewBox="0 0 72 48"><path d="M8 8 Q 18 24 8 40 Q 32 40 52 24 Q 32 8 8 8 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="16" y2="16" stroke="currentColor" stroke-width="2"/><line x1="0" y1="32" x2="16" y2="32" stroke="currentColor" stroke-width="2"/><line x1="52" y1="24" x2="72" y2="24" stroke="currentColor" stroke-width="2"/></svg>`,
                'NOT': `<svg viewBox="0 0 56 40"><path d="M8 4 L40 20 L8 36 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><circle cx="46" cy="20" r="5" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="20" x2="8" y2="20" stroke="currentColor" stroke-width="2"/><line x1="51" y1="20" x2="56" y2="20" stroke="currentColor" stroke-width="2"/></svg>`,
                'NAND': `<svg viewBox="0 0 72 48"><path d="M10 8 L30 8 A 16 20 0 0 1 30 40 L10 40 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><circle cx="52" cy="24" r="5" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="10" y2="16" stroke="currentColor" stroke-width="2"/><line x1="0" y1="32" x2="10" y2="32" stroke="currentColor" stroke-width="2"/><line x1="57" y1="24" x2="72" y2="24" stroke="currentColor" stroke-width="2"/></svg>`,
                'NOR': `<svg viewBox="0 0 72 48"><path d="M6 8 Q 16 24 6 40 Q 28 40 44 24 Q 28 8 6 8 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><circle cx="52" cy="24" r="5" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="14" y2="16" stroke="currentColor" stroke-width="2"/><line x1="0" y1="32" x2="14" y2="32" stroke="currentColor" stroke-width="2"/><line x1="57" y1="24" x2="72" y2="24" stroke="currentColor" stroke-width="2"/></svg>`,
                'XOR': `<svg viewBox="0 0 72 48"><path d="M14 8 Q 24 24 14 40 Q 36 40 54 24 Q 36 8 14 8 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><path d="M6 8 Q 16 24 6 40" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="18" y2="16" stroke="currentColor" stroke-width="2"/><line x1="0" y1="32" x2="18" y2="32" stroke="currentColor" stroke-width="2"/><line x1="54" y1="24" x2="72" y2="24" stroke="currentColor" stroke-width="2"/></svg>`,
                'XNOR': `<svg viewBox="0 0 72 48"><path d="M14 8 Q 24 24 14 40 Q 34 40 48 24 Q 34 8 14 8 Z" fill="none" stroke="currentColor" stroke-width="2.5"/><path d="M6 8 Q 16 24 6 40" fill="none" stroke="currentColor" stroke-width="2.5"/><circle cx="54" cy="24" r="5" fill="none" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="18" y2="16" stroke="currentColor" stroke-width="2"/><line x1="0" y1="32" x2="18" y2="32" stroke="currentColor" stroke-width="2"/><line x1="59" y1="24" x2="72" y2="24" stroke="currentColor" stroke-width="2"/></svg>`,
                // IO Components
                'SWITCH': `<svg viewBox="0 0 44 44"><circle cx="22" cy="22" r="18" fill="none" stroke="currentColor" stroke-width="3"/><line x1="22" y1="10" x2="22" y2="22" stroke="currentColor" stroke-width="3" stroke-linecap="round"/><line x1="40" y1="22" x2="44" y2="22" stroke="currentColor" stroke-width="2"/></svg>`,
                'LED': `<svg viewBox="0 0 32 32"><circle cx="16" cy="16" r="12" fill="currentFill" stroke="currentColor" stroke-width="2.5"/><line x1="0" y1="16" x2="4" y2="16" stroke="currentColor" stroke-width="2"/></svg>`,
                'CLOCK': `<svg viewBox="0 0 56 40"><rect x="4" y="6" width="48" height="28" rx="3" fill="none" stroke="currentColor" stroke-width="2"/><polyline points="10,26 10,14 18,14 18,26 26,26 26,14 34,14 34,26 42,26 42,14 46,14" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linejoin="miter"/><line x1="52" y1="20" x2="56" y2="20" stroke="currentColor" stroke-width="2"/></svg>`,
                'JOINT': `<svg viewBox="0 0 12 12"><circle cx="6" cy="6" r="5" fill="currentColor" stroke="none"/></svg>`,
                // Expert Mode Components
                'TRANSISTOR': `<svg viewBox="0 0 56 56"><circle cx="28" cy="28" r="24" fill="none" stroke="currentColor" stroke-width="2"/><line x1="20" y1="16" x2="20" y2="40" stroke="currentColor" stroke-width="3"/><line x1="0" y1="28" x2="20" y2="28" stroke="currentColor" stroke-width="2"/><line x1="20" y1="22" x2="40" y2="10" stroke="currentColor" stroke-width="2"/><line x1="40" y1="10" x2="40" y2="0" stroke="currentColor" stroke-width="2"/><line x1="20" y1="34" x2="40" y2="46" stroke="currentColor" stroke-width="2"/><line x1="40" y1="46" x2="40" y2="56" stroke="currentColor" stroke-width="2"/><polygon points="34,42 40,46 36,48" fill="currentColor"/></svg>`,
                'PMOS': `<svg viewBox="0 0 56 56"><circle cx="28" cy="28" r="24" fill="none" stroke="currentColor" stroke-width="2"/><line x1="20" y1="16" x2="20" y2="40" stroke="currentColor" stroke-width="3"/><line x1="0" y1="28" x2="14" y2="28" stroke="currentColor" stroke-width="2"/><circle cx="17" cy="28" r="3" fill="none" stroke="currentColor" stroke-width="2"/><line x1="20" y1="22" x2="40" y2="10" stroke="currentColor" stroke-width="2"/><line x1="40" y1="10" x2="40" y2="0" stroke="currentColor" stroke-width="2"/><line x1="20" y1="34" x2="40" y2="46" stroke="currentColor" stroke-width="2"/><line x1="40" y1="46" x2="40" y2="56" stroke="currentColor" stroke-width="2"/></svg>`,
                'VCC': `<svg viewBox="0 0 36 36"><line x1="18" y1="16" x2="18" y2="36" stroke="currentColor" stroke-width="3"/><polygon points="8,16 28,16 18,4" fill="currentColor" stroke="currentColor" stroke-width="2"/></svg>`,
                'GND': `<svg viewBox="0 0 36 36"><line x1="18" y1="0" x2="18" y2="16" stroke="currentColor" stroke-width="3"/><line x1="6" y1="16" x2="30" y2="16" stroke="currentColor" stroke-width="3"/><line x1="10" y1="22" x2="26" y2="22" stroke="currentColor" stroke-width="2.5"/><line x1="14" y1="28" x2="22" y2="28" stroke="currentColor" stroke-width="2"/></svg>`
            };

            // 1-3. íƒ€ì…ë³„ ì„¤ì • ë° í•€ ë°°ì¹˜
            if (type === 'SWITCH') {
                el.innerHTML = symbols['SWITCH'];
                label.innerText = 'OFF';
                el.appendChild(label);
                el.onclick = (e) => this.toggleSwitch(e, el);
                this.addPin(el, 'out', 'output center');
            } else if (type === 'LED') {
                el.innerHTML = symbols['LED'];
                el.setAttribute('data-color', 'red'); // ê¸°ë³¸ ìƒ‰ìƒ
                label.innerText = '';
                el.appendChild(label);
                this.addPin(el, 'in-1', 'input center');
            } else if (type === 'CLOCK') {
                el.innerHTML = symbols['CLOCK'];
                label.innerText = 'CLK';
                el.appendChild(label);
                el.classList.add('comp-clock');
                this.addPin(el, 'out', 'output center');
            } else if (type === 'JOINT') {
                el.innerHTML = symbols['JOINT'];
                label.style.display = 'none';
                el.appendChild(label);
                this.addPin(el, 'in-out', 'input output center');
            } else if (type === 'TRANSISTOR') {
                el.innerHTML = symbols['TRANSISTOR'];
                label.innerText = 'NPN';
                el.appendChild(label);
                this.addPin(el, 'base', 'input base');
                this.addPin(el, 'col', 'input col');
                this.addPin(el, 'emit', 'output emit');
            } else if (['VCC', 'GND', 'PORT_IN', 'PORT_OUT', 'PMOS'].includes(type)) {
                if (type === 'VCC') {
                    el.innerHTML = symbols['VCC'];
                    label.innerText = 'VCC';
                    el.appendChild(label);
                    this.addPin(el, 'out', 'output center');
                    el.setAttribute('data-value', '1');
                } else if (type === 'GND') {
                    el.innerHTML = symbols['GND'];
                    label.innerText = 'GND';
                    el.appendChild(label);
                    this.addPin(el, 'out', 'output center');
                    el.setAttribute('data-value', '0');
                } else if (type === 'PMOS') {
                    el.innerHTML = symbols['PMOS'];
                    label.innerText = 'PMOS';
                    el.appendChild(label);
                    this.addPin(el, 'base', 'input base');
                    this.addPin(el, 'col', 'input col');
                    this.addPin(el, 'emit', 'output emit');
                } else if (type === 'PORT_IN') {
                    label.innerText = 'IN';
                    this.addPin(el, 'out', 'output center');
                } else if (type === 'PORT_OUT') {
                    label.innerText = 'OUT';
                    this.addPin(el, 'in', 'input center');
                }
            } else {
                // ë¡œì§ ê²Œì´íŠ¸ - SVG ì‹¬ë³¼ ì‚½ì…
                if (symbols[type]) {
                    el.innerHTML = symbols[type];
                    label.innerText = type;
                    el.appendChild(label);
                } else {
                    label.innerText = type;
                }

                this.addPin(el, 'out', 'output center');

                if (type === 'NOT') {
                    this.addPin(el, 'in-1', 'input center');
                } else {
                    this.addPin(el, 'in-1', 'input in-1');
                    this.addPin(el, 'in-2', 'input in-2');
                }
            }

            // 1-4. ìœ„ì¹˜ ì§€ì •
            // Safe Scale Check
            const scale = this.scale || 1.0;
            if (x !== null && y !== null) {
                el.style.left = `${x}px`;
                el.style.top = `${y}px`;
            } else {
                const panX = this.panX || 0;
                const panY = this.panY || 0;
                const spawnX = (-panX + 300 + Math.random() * 50) / scale;
                const spawnY = (-panY + 200 + Math.random() * 50) / scale;
                el.style.left = `${spawnX}px`;
                el.style.top = `${spawnY}px`;
            }

            // Setup Internals
            if (GATE_SCHEMATICS[type]) {
                el.internals = { components: [], wires: [] };
                this.buildInternals(el, GATE_SCHEMATICS[type]);
            } else if (!el.internals) {
                el.internals = null;
            }

            if (this.workspace) {
                this.workspace.appendChild(el);
                this.components.push(el);
            } else {
                alert("Error: Workspace not found!");
            }

            // Double click handling - [Removed by User Request]
            // el.ondblclick = (e) => {
            //     e.stopPropagation();
            //     if (this.userMode === 'expert') {
            //         if (el.internals || GATE_SCHEMATICS[type]) {
            //             this.enterComponent(el);
            //         } else {
            //             this.openPropertyModal(el);
            //         }
            //     }
            // };
        } catch (err) {
            this.showToast(`ë¶€í’ˆ ì¶”ê°€ ì‹¤íŒ¨: ${err.message}`, 'error');
            console.error(err);
            return null; // [FIX] ì‹¤íŒ¨ ì‹œ ëª…ì‹œì ìœ¼ë¡œ null ë°˜í™˜
        }

        // íˆìŠ¤í† ë¦¬ ì €ì¥ (Undo ì§€ì›)
        this.saveState();
        return el; // [FIX] ì„±ê³µ ì‹œ element ë°˜í™˜
    }

    resizeCanvas(w, h) {
        // Default values if not provided
        const width = w || this.wireLayer?.getAttribute('width') || 6000;
        const height = h || this.wireLayer?.getAttribute('height') || 4000;

        if (this.wireLayer) {
            this.wireLayer.setAttribute('width', width);
            this.wireLayer.setAttribute('height', height);
            this.wireLayer.style.width = width + 'px';
            this.wireLayer.style.height = height + 'px';
        }

        // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
        this.updateMinimap();
    }

    saveProject(silent = false) {
        if (!this.currentProjectId) return;

        // 1. ë¶€í’ˆ ì €ì¥
        const componentsData = this.components.map(comp => {
            const data = {
                id: comp.id,
                type: comp.getAttribute('data-type'),
                x: parseFloat(comp.style.left),
                y: parseFloat(comp.style.top),
                value: comp.getAttribute('data-value')
            };

            if (comp.internals) {
                data.internals = {
                    components: comp.internals.components.map(c => ({
                        id: c.id,
                        type: c.getAttribute('data-type'),
                        x: parseFloat(c.style.left),
                        y: parseFloat(c.style.top),
                        value: c.getAttribute('data-value'),
                        label: c.querySelector('.comp-label')?.innerText
                    })),
                    wires: comp.internals.wires.map(w => ({
                        fromCompId: w.from.parentElement.id,
                        fromPinClass: w.from.classList[1],
                        toCompId: w.to.parentElement.id,
                        toPinClass: w.to.classList[1]
                    }))
                };
            }
            return data;
        });

        // 2. ì „ì„  ì €ì¥
        const wiresData = this.wires.map(wire => {
            const fromComp = wire.from.closest('.component');
            const toComp = wire.to.closest('.component');

            if (!fromComp || !toComp) return null;

            return {
                fromCompId: fromComp.id,
                fromPinClass: wire.from.classList[1],
                toCompId: toComp.id,
                toPinClass: wire.to.classList[1]
            };
        }).filter(w => w !== null);

        const projectData = {
            name: this.currentProjectName,
            lastModified: new Date().toLocaleString(),
            components: componentsData,
            wires: wiresData
        };

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        localStorage.setItem(this.currentProjectId, JSON.stringify(projectData));

        // í”„ë¡œì íŠ¸ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸ (ì¤‘ë³µ ì œê±°)
        let projectIndex = JSON.parse(localStorage.getItem('logic_sim_projects_index')) || [];
        if (!projectIndex.includes(this.currentProjectId)) {
            projectIndex.push(this.currentProjectId);
            localStorage.setItem('logic_sim_projects_index', JSON.stringify(projectIndex));
        }

        if (!silent) this.showToast(`âœ“ í”„ë¡œì íŠ¸ ì €ì¥ë¨`, 'success');
    }

    loadProject(projectId) {
        const json = localStorage.getItem(projectId);
        if (!json) {
            alert("í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }

        const projectData = JSON.parse(json);
        this.currentProjectName = projectData.name;

        // ì´ˆê¸°í™”
        this.components.forEach(c => c.remove());
        this.components = [];
        this.wires.forEach(w => w.line.remove());
        this.wires = [];
        this.wireLayer.innerHTML = '';

        // 1. ë¶€í’ˆ ë³µì›
        const compMap = {}; // ID -> Element ë§¤í•‘
        projectData.components.forEach(cData => {
            // addModule ë©”ì„œë“œ ì¬í™œìš© (IDëŠ” ìƒˆë¡œ ìƒì„±ë˜ë¯€ë¡œ ë®ì–´ì”Œì›€)
            this.addModule(cData.type, cData.x, cData.y);
            const newComp = this.components[this.components.length - 1];

            // ê¸°ì¡´ ID ë³µêµ¬ (ì¤‘ìš”: ì „ì„  ì—°ê²° ìœ„í•´)
            newComp.id = cData.id;
            // ê°’ ë³µêµ¬
            if (cData.value) newComp.setAttribute('data-value', cData.value);

            // ìŠ¤ìœ„ì¹˜ ë“±ì˜ ìƒíƒœ ì‹œê°ì  ë³µêµ¬
            if (cData.type === 'SWITCH') {
                const label = newComp.querySelector('.comp-label');
                if (label) label.innerText = cData.value === '1' ? 'ON' : 'OFF';
                newComp.style.background = cData.value === '1' ? '#2ecc71' : '#27ae60';
            }

            compMap[cData.id] = newComp;

            // 1.5 Internals ë³µêµ¬
            if (cData.internals) {
                this.restoreInternals(newComp, cData.internals);
            }
        });

        // 2. ì „ì„  ë³µì›
        projectData.wires.forEach(wData => {
            const fromComp = compMap[wData.fromCompId];
            const toComp = compMap[wData.toCompId];

            if (fromComp && toComp) {
                const fromPin = fromComp.querySelector(`.${wData.fromPinClass}`);
                const toPin = toComp.querySelector(`.${wData.toPinClass}`);

                if (fromPin && toPin) {
                    this.createWire(fromPin, toPin);
                }
            }
        });

        this.updateCircuit();
    }

    initEvents() {
        window.addEventListener('mousedown', (e) => this.onMouseDown(e));
        window.addEventListener('mousemove', (e) => this.onMouseMove(e));
        window.addEventListener('mouseup', () => this.onMouseUp());
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));

        // ë§ˆìš°ìŠ¤ê°€ ì°½ ë°–ìœ¼ë¡œ ë‚˜ê°”ì„ ë•Œ ë“œë˜ê·¸ ìƒíƒœ í•´ì œ
        document.addEventListener('mouseleave', () => this.resetDragState());
        window.addEventListener('blur', () => this.resetDragState());

        // ë§ˆìš°ìŠ¤ íœ  ì¤Œ
        if (this.workspace) {
            this.workspace.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                this.zoom(delta);
            }, { passive: false });
        }

        // [CRITICAL FIX] Wire Layer Click Passthrough
        // Ensure wire layer never blocks clicks intended for workspace or components
        if (this.wireLayer) {
            this.wireLayer.style.pointerEvents = 'none';
            this.wireLayer.style.zIndex = '1'; // Low z-index
            this.wireLayer.style.overflow = 'visible';
        }

        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ìƒíƒœë°” ì—…ë°ì´íŠ¸
        window.addEventListener('mousemove', (e) => {
            if (this.workspace) {
                const rect = this.workspace.parentElement.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left - this.panX) / this.scale);
                const y = Math.round((e.clientY - rect.top - this.panY) / this.scale);
                const posEl = document.getElementById('status-position');
                if (posEl) posEl.textContent = `X: ${x}, Y: ${y}`;
            }
        });

        // ìš°í´ë¦­ ë©”ë‰´ ê´€ë ¨
        window.addEventListener('contextmenu', (e) => e.preventDefault()); // ê¸°ë³¸ ë©”ë‰´ ì°¨ë‹¨
        window.addEventListener('click', () => this.hideContextMenu());    // í´ë¦­ ì‹œ ë©”ë‰´ ë‹«ê¸°

        // â˜… [NEW] Manual Button Binding to ensure they work
        // This is redundancy in case HTML onclick fails
        setTimeout(() => {
            const buttons = document.querySelectorAll('.tool-btn');
            buttons.forEach(btn => {
                const onclick = btn.getAttribute('onclick');
                if (onclick && onclick.includes('addModule')) {
                    // Extract type from string: sim.addModule('AND')
                    const match = onclick.match(/'([^']+)'/);
                    if (match && match[1]) {
                        const type = match[1];
                        // Removing onclick attribute to prevent double firing if we rely on JS
                        // But for now, lets just leave it. If HTML onclick works, fine. 
                        // But if user says it doesn't...
                        // Let's add click listener ONLY if onclick is removed or we assume it failed.
                        // Actually, inline onclick is best if working.
                        // We will rely on window.sim = this.
                    }
                }
            });
        }, 500);
    }

    buildInternals(parentComp, schematic) {
        // Create components and wires in memory (not DOM yet, unless we view them?)
        // Crucial: We need DOM elements to run logic? Yes, current logic relies on DOM attributes.
        // So we will create them but keeping them detached from workspace? 
        // Or better: Create a DocumentFragment or a hidden container?
        // Actually, the simplest way to allow `evaluateComposite` to work without viewing 
        // is to have them exist as objects. But `updateCircuit` uses `querySelector`.
        // So, we MUST instantiate them. We can put them in a hidden div or just keep them in memory 
        // ensuring `querySelector` calls in `propagate` are replaced by lookups.
        // CHECK: `propagate` uses `comp.querySelector`. So elements must have children.
        // Solution: Create the DOM elements but don't append to `workspace` until we `enterComponent`.

        parentComp.internals = { components: [], wires: [] };
        const idMap = {};

        schematic.parts.forEach(part => {
            const el = document.createElement('div');
            el.classList.add('component');
            // Fake IDs specific to this scope
            el.id = parentComp.id + '_' + part.id;
            el.setAttribute('data-type', part.type);
            el.setAttribute('data-value', '0');
            el.style.left = part.x + 'px';
            el.style.top = part.y + 'px';

            // Label
            const label = document.createElement('div');
            label.classList.add('comp-label');
            label.innerText = part.label || part.type;
            el.appendChild(label);

            // Pins (Reuse logic? addPin attaches to DOM)
            // We need to manually add pins or call a helper that operates on 'el'
            // I'll reuse the logic block from addModule but simplified:
            const type = part.type;
            if (type === 'TRANSISTOR' || type === 'PMOS') {
                this.addPin(el, 'base', 'input base');
                this.addPin(el, 'col', 'input col');
                this.addPin(el, 'emit', 'output emit');
            } else if (type === 'VCC' || type === 'GND' || type === 'PORT_IN') {
                if (type === 'VCC') el.setAttribute('data-value', '1');
                if (type === 'GND') el.setAttribute('data-value', '0');
                this.addPin(el, 'out', 'output center');
            } else if (type === 'PORT_OUT') {
                this.addPin(el, 'in', 'input center');
            }

            // Store special ref
            if (part.id) idMap[part.id] = el;

            parentComp.internals.components.push(el);
        });

        // Wires
        schematic.wires.forEach(w => {
            // parse "t1.col" -> component t1, pin class 'col'
            const [fromId, fromPinCls] = w.from.split('.');
            const [toId, toPinCls] = w.to.split('.');

            const fromComp = idMap[fromId];
            const toComp = idMap[toId];

            if (fromComp && toComp) {
                const fromPin = fromComp.querySelector('.' + fromPinCls);
                const toPin = toComp.querySelector('.' + toPinCls);
                if (fromPin && toPin) {
                    // Create SVG line (detached)
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    parentComp.internals.wires.push({ from: fromPin, to: toPin, line: line });
                }
            }
        });
    }

    enterComponent(comp) {
        // ë‚´ë¶€ ëª¨ë‹¬ì´ ì—†ìœ¼ë©´ ê¸°ëŠ¥ ë¹„í™œì„±í™”
        if (!this.internalModal || !this.internalWorkspace) {
            console.log('Internal editor not available in this layout');
            alert('ë‚´ë¶€ êµ¬ì¡° ë³´ê¸° ê¸°ëŠ¥ì€ í˜„ì¬ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }

        if (!comp.internals) {
            // Build defaults if missing (fallback) or empty
            comp.internals = { components: [], wires: [] };
        }

        // 1. Save Current State (Main Scope)
        this.scopeStack.push({
            components: this.components,
            wires: this.wires,
            scopeComp: this.currentScopeComp,
            panX: this.panX,
            panY: this.panY,
            scale: this.scale
        });

        // 2. Switch Context to Internal Editor (View-Only Mode)
        this.internalModal.style.display = 'flex';
        this.workspace = this.internalWorkspace;
        this.wireLayer = this.internalWireLayer;

        const compType = comp.getAttribute('data-type');
        if (this.internalTitle) {
            this.internalTitle.innerText = `ğŸ” ${compType} ë‚´ë¶€ êµ¬ì¡° (ë³´ê¸° ì „ìš©)`;
        }

        this.currentScopeComp = comp;
        this.components = comp.internals.components;
        this.wires = comp.internals.wires;

        // 3. Render Internals (Clone for view-only to prevent accidental edits)
        if (this.workspace) {
            this.components.forEach(c => {
                c.style.pointerEvents = 'none';
                this.workspace.appendChild(c);
            });
        }
        if (this.wireLayer) {
            this.wires.forEach(w => this.wireLayer.appendChild(w.line));
        }

        // 4. Reset View for Editor
        this.panX = 0;
        this.panY = 0;
        this.scale = 1.0;
        this.updateTransform();

        // Hide Main Selection Box if active
        if (this.selectionBox) this.selectionBox.style.display = 'none';
    }

    exitComponent() {
        if (this.scopeStack.length === 0) return;

        // 1. Detach Internals (Save to memory object)
        this.components.forEach(c => c.remove());
        this.wires.forEach(w => w.line.remove());

        // 2. Restore Parent State
        const savedState = this.scopeStack.pop();

        this.components = savedState.components;
        this.wires = savedState.wires;

        // 3. Restore Context
        if (this.internalModal) this.internalModal.style.display = 'none';
        this.workspace = this.mainWorkspace;
        this.wireLayer = this.mainWireLayer;

        this.panX = savedState.panX;
        this.panY = savedState.panY;
        this.scale = savedState.scale;

        // Restore `currentScopeComp`
        this.currentScopeComp = savedState.scopeComp;

        // Re-append components and wires to the main workspace/wireLayer
        if (this.workspace) {
            this.components.forEach(comp => {
                this.workspace.appendChild(comp);
            });
        }
        if (this.wireLayer) {
            this.wires.forEach(wire => {
                this.wireLayer.appendChild(wire.line);
            });
        }

        this.updateTransform();

        // Update UI
        // Hide Back Button if no more parents
        if (this.scopeStack.length === 0) {
            const backBtn = document.getElementById('btn-back-parent');
            if (backBtn) backBtn.style.display = 'none';
        }
    }

    getDefaultTransistors(type) {
        switch (type) {
            case 'NOT': return 2;
            case 'AND': return 6;
            case 'OR': return 6;
            case 'NAND': return 4;
            case 'NOR': return 4;
            case 'XNOR': return 10;
            case 'JOINT': return 0;
            case 'TRANSISTOR': return 1;
            default: return 0;
        }
    }

    addPin(parent, posClass, roleString) {
        const pin = document.createElement('div');
        // roleStringì— 'center' ê°™ì€ í´ë˜ìŠ¤ê°€ í¬í•¨ë˜ì–´ ì˜¬ ìˆ˜ ìˆìŒ
        pin.className = `pin ${posClass}`;

        // ì‹¤ì œ ë¡œì§ìš© roleì€ 'input' ë˜ëŠ” 'output'ë§Œ ì¶”ì¶œ
        const role = roleString.includes('input') ? 'input' : 'output';
        pin.setAttribute('data-role', role);

        // ë“œë˜ê·¸ë¡œ ì „ì„  ì—°ê²° (ëˆ„ë¥´ë©´ ì‹œì‘, ë–¼ë©´ ì—°ê²°)
        pin.onmousedown = (e) => {
            const parentType = parent.getAttribute('data-type');

            // JOINTì¸ ê²½ìš°: ë“œë˜ê·¸ ìš°ì„  (ì „ì„  ì—°ê²° ëŒ€ì‹ )
            if (parentType === 'JOINT') {
                // JOINTë¥¼ ë“œë˜ê·¸í•˜ê¸° ìœ„í•´ ì´ë²¤íŠ¸ë¥¼ ì „íŒŒì‹œí‚´
                // ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ì˜ mousedownì´ ì²˜ë¦¬í•˜ë„ë¡
                return; // stopPropagation ì—†ì´ ë¦¬í„´ -> ì´ë²¤íŠ¸ ë²„ë¸”ë§
            }

            e.stopPropagation(); // ë¶€í’ˆ ë“œë˜ê·¸ ë°©ì§€
            e.preventDefault();

            // Edit ë˜ëŠ” Wire ëª¨ë“œì—ì„œë§Œ ì—°ê²°
            if (this.mode !== 'edit' && this.mode !== 'wire') return;

            // ì´ë¯¸ ì™€ì´ì–´ë§ ì¤‘ì´ë©´ ì´ í•€ì— ì—°ê²°
            if (this.startPin && this.tempLine) {
                this.createWire(this.startPin, pin);
                this.cancelWiring();
                this.updateCircuit();
                return;
            }

            // ìƒˆ ì™€ì´ì–´ë§ ì‹œì‘
            this.startPin = pin;
            pin.classList.add('active');

            // ì„ì‹œ ì„  ìƒì„±
            const wsRect = this.workspace.parentElement.getBoundingClientRect();
            const pinRect = pin.getBoundingClientRect();
            const startX = (pinRect.left + pinRect.width / 2 - wsRect.left - this.panX) / this.scale;
            const startY = (pinRect.top + pinRect.height / 2 - wsRect.top - this.panY) / this.scale;

            this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this.tempLine.setAttribute('fill', 'none');
            this.tempLine.setAttribute('d', `M ${startX} ${startY} L ${startX} ${startY}`);
            this.tempLine.style.stroke = 'var(--accent-blue)';
            this.tempLine.style.strokeWidth = '3';
            this.tempLine.style.strokeDasharray = '6,4';
            this.tempLine.style.opacity = '0.8';
            this.wireLayer.appendChild(this.tempLine);
        };

        // í•€ ìœ„ì—ì„œ ë§ˆìš°ìŠ¤ë¥¼ ë–¼ë©´ ì—°ê²°
        pin.onmouseup = (e) => {
            e.stopPropagation();
            if (this.startPin && this.startPin !== pin) {
                this.createWire(this.startPin, pin);
                this.cancelWiring();
                this.updateCircuit();
            }
        };

        parent.appendChild(pin);
    }

    // =========================================================
    // [Section 2] ë§ˆìš°ìŠ¤ ì¡°ì‘ (ì„ íƒ, ë“œë˜ê·¸, ì¤Œ/íŒ¬)
    // =========================================================

    // â˜… [NEW] ì»´í¬ë„ŒíŠ¸ ì „ìš© ë§ˆìš°ìŠ¤ í•¸ë“¤ëŸ¬ (ìš°ì„ ìˆœìœ„ í™•ë³´)
    handleComponentMouseDown(e, target) {
        if (e.button !== 0) return; // ì¢Œí´ë¦­ ì™¸ì—ëŠ” ë²„ë¸”ë§ í—ˆìš© (íœ í´ë¦­ íŒ¨ë‹ ë“±)

        e.stopPropagation(); // ë°°ê²½(Workspace) í´ë¦­ ë°©ì§€

        // Ctrl í‚¤ ì—†ìœ¼ë©´ ë‹¨ì¼ ì„ íƒìœ¼ë¡œ ë³€ê²½
        const isAlreadySelected = this.selectedComponents.includes(target);
        this.componentWasSelected = isAlreadySelected; // í´ë¦­ ì‹œ í† ê¸€ ë°©ì§€ìš© ìƒíƒœ ì €ì¥

        if (!e.ctrlKey && !isAlreadySelected) {
            this.clearSelection();
        }
        this.selectComponent(target, true);

        this.dragTarget = target;

        // Calculate Mouse Position in Model Logic Space
        const wsRect = this.workspace.parentElement.getBoundingClientRect();
        const mouseX = (e.clientX - wsRect.left - this.panX) / this.scale;
        const mouseY = (e.clientY - wsRect.top - this.panY) / this.scale;

        // Current Component Position (Model Space)
        const compX = parseFloat(this.dragTarget.style.left) || 0;
        const compY = parseFloat(this.dragTarget.style.top) || 0;

        // Offset = Mouse - Component
        this.dragOffset.x = mouseX - compX;
        this.dragOffset.y = mouseY - compY;

        this.dragTarget.style.cursor = 'grabbing';
    }

    onMouseDown(e) {
        // [ìˆ˜ì •] íœ  í´ë¦­(ë²„íŠ¼ 1) ë˜ëŠ” Pan ëª¨ë“œ -> í™”ë©´ ì´ë™
        if (e.button === 1 || this.mode === 'pan') {
            e.preventDefault(); // íœ  í´ë¦­ ì‹œ ìë™ ìŠ¤í¬ë¡¤ ì»¤ì„œ ë°©ì§€
            this.isPanning = true;
            this.lastMouse = { x: e.clientX, y: e.clientY };
            this.workspace.style.cursor = 'grabbing';
            return;
        }

        // ì¢Œí´ë¦­(ë²„íŠ¼ 0)ì´ ì•„ë‹ˆë©´ ì„ íƒ/ë“œë˜ê·¸ ë¡œì§ ê±´ë„ˆëœ€
        if (e.button !== 0) return;

        // B. ë¶€í’ˆ í´ë¦­ ë¡œì§ì€ handleComponentMouseDownìœ¼ë¡œ ì´ë™ë¨.
        // í•˜ì§€ë§Œ ê¸°ì¡´ ìƒì„±ëœ ë¶€í’ˆì´ë‚˜ HTML êµ¬ì¡°ìƒ window ì´ë²¤íŠ¸ë¡œ ë“¤ì–´ì˜¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ
        // ì•ˆì „ì¥ì¹˜ë¡œ ë‚¨ê²¨ë‘ë˜, ì§ì ‘ ì—°ê²° ë°©ì‹ì´ ìš°ì„ í•¨.
        if (e.target.closest('.component')) {
            // ì´ë¯¸ el.onmousedownì—ì„œ ì²˜ë¦¬ë˜ì—ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” íŒ¨ìŠ¤í•˜ê±°ë‚˜
            // e.stopPropagation()ì´ ë™ì‘í–ˆë‹¤ë©´ ì—¬ê¸° ë„ë‹¬í•˜ì§€ ì•ŠìŒ.
            return;
        }

        // B. ë¶€í’ˆ í´ë¦­ (ì„ íƒ ë° ë“œë˜ê·¸ ì¤€ë¹„)
        if (e.target.closest('.component')) {
            const target = e.target.closest('.component');

            // Ctrl í‚¤ ì—†ìœ¼ë©´ ë‹¨ì¼ ì„ íƒìœ¼ë¡œ ë³€ê²½
            if (!e.ctrlKey && !this.selectedComponents.includes(target)) {
                this.clearSelection();
            }
            this.selectComponent(target, true);

            this.dragTarget = target;

            // Calculate Mouse Position in Model Logic Space
            const wsRect = this.workspace.parentElement.getBoundingClientRect();
            const mouseX = (e.clientX - wsRect.left - this.panX) / this.scale;
            const mouseY = (e.clientY - wsRect.top - this.panY) / this.scale;

            // Current Component Position (Model Space)
            const compX = parseFloat(this.dragTarget.style.left) || 0;
            const compY = parseFloat(this.dragTarget.style.top) || 0;

            // Offset = Mouse - Component
            this.dragOffset.x = mouseX - compX;
            this.dragOffset.y = mouseY - compY;

            this.dragTarget.style.cursor = 'grabbing';
            return;
        }

        // C. ë¹ˆ ê³µê°„ í´ë¦­ (ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì˜ì—­ ë‚´ì—ì„œë§Œ)
        const workspaceWrapper = e.target.closest('.workspace-wrapper');
        const isOnWorkspace = e.target.id === 'workspace' || e.target === this.workspace;
        const isOnWireLayer = e.target.id === 'wire-layer' || e.target.closest('#wire-layer');
        const isNotComponent = !e.target.closest('.component') && !e.target.closest('.pin');

        const isEmptySpace = workspaceWrapper && isNotComponent && (isOnWorkspace || isOnWireLayer || e.target.closest('#workspace'));

        if (isEmptySpace) {
            console.log('Empty space clicked - starting selection box');
            // [All Modes] Wiring in empty space -> Create Joint (Allow wire bending for everyone)
            if (this.startPin) {
                // Prevent drag/select logic
                this.clearSelection();

                // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— JOINT ìƒì„±
                const wsRect = this.workspace.parentElement.getBoundingClientRect();
                const mouseX = (e.clientX - wsRect.left - this.panX) / this.scale;
                const mouseY = (e.clientY - wsRect.top - this.panY) / this.scale;

                // 1. Create Joint (14px x 14px -> offset 7px to center)
                try {
                    this.addModule('JOINT', mouseX - 7, mouseY - 7);
                    const newJoint = this.components[this.components.length - 1];

                    if (newJoint) {
                        const jointPin = newJoint.querySelector('.pin');

                        // 2. Connect current startPin to this Joint
                        if (jointPin) {
                            this.createWire(this.startPin, jointPin);
                            this.cancelWiring();
                            this.updateCircuit();
                        }
                    }
                } catch (err) {
                    console.error("JOINT creation error:", err);
                    this.cancelWiring();
                }
                return;
            }

            // Start box selection
            this.clearSelection();
            this.isSelecting = true;
            const wsRect = this.workspace.parentElement.getBoundingClientRect();
            this.selectionStart = {
                x: (e.clientX - wsRect.left - this.panX) / this.scale,
                y: (e.clientY - wsRect.top - this.panY) / this.scale
            };
            this.selectionBox.style.left = this.selectionStart.x * this.scale + this.panX + 'px';
            this.selectionBox.style.top = this.selectionStart.y * this.scale + this.panY + 'px';
            this.selectionBox.style.width = '0px';
            this.selectionBox.style.height = '0px';
            this.selectionBox.style.display = 'block';
        }
    }

    onMouseMove(e) {
        // [Safety Fix] Force Drag Release
        // ë¸Œë¼ìš°ì €ê°€ MouseUp ì´ë²¤íŠ¸ë¥¼ ë†“ì³¤ë”ë¼ë„, ë²„íŠ¼ì´ ëˆŒë ¤ìˆì§€ ì•Šë‹¤ë©´ ì¦‰ì‹œ ë“œë˜ê·¸ í•´ì œ
        if (this.dragTarget && e.buttons === 0) {
            this.onMouseUp(e);
            return;
        }

        // A. í™”ë©´ ì´ë™ (Panning)
        if (this.isPanning) {
            const dx = e.clientX - this.lastMouse.x;
            const dy = e.clientY - this.lastMouse.y;
            this.panX += dx;
            this.panY += dy;
            this.lastMouse = { x: e.clientX, y: e.clientY };
            this.updateTransform();
            return;
        }

        const wsRect = this.workspace.parentElement.getBoundingClientRect();
        // í˜„ì¬ ë§ˆìš°ìŠ¤ ì¢Œí‘œ (Workspace ê¸°ì¤€ ì—­ì‚°)
        const mouseX = (e.clientX - wsRect.left - this.panX) / this.scale;
        const mouseY = (e.clientY - wsRect.top - this.panY) / this.scale;

        // B. ë“œë˜ê·¸ ì„ íƒ ë°•ìŠ¤ í¬ê¸° ì¡°ì ˆ
        if (this.isSelecting) {
            const width = Math.abs(mouseX - this.selectionStart.x);
            const height = Math.abs(mouseY - this.selectionStart.y);
            const left = Math.min(mouseX, this.selectionStart.x);
            const top = Math.min(mouseY, this.selectionStart.y);

            this.selectionBox.style.width = width * this.scale + 'px';
            this.selectionBox.style.height = height * this.scale + 'px';
            this.selectionBox.style.left = left * this.scale + this.panX + 'px';
            this.selectionBox.style.top = top * this.scale + this.panY + 'px';
            return;
        }

        // C. ë¶€í’ˆ ë“œë˜ê·¸ (ë‹¤ì¤‘ ì„ íƒ ì§€ì›)
        if (this.dragTarget) {
            let newX = mouseX - this.dragOffset.x;
            let newY = mouseY - this.dragOffset.y;

            // ê·¸ë¦¬ë“œ ìŠ¤ëƒ… ì ìš© (í™œì„±í™”ëœ ê²½ìš°)
            let snapX = this.gridSnap ? Math.round(newX / this.gridSize) * this.gridSize : newX;
            let snapY = this.gridSnap ? Math.round(newY / this.gridSize) * this.gridSize : newY;

            // â˜… ì˜ì—­ ì œí•œ: ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ëª»í•˜ê²Œ (ìµœì†Œ 0, ìµœëŒ€ëŠ” ìº”ë²„ìŠ¤ í¬ê¸°)
            const compWidth = this.dragTarget.offsetWidth || 72;
            const compHeight = this.dragTarget.offsetHeight || 48;
            const canvasWidth = parseInt(this.wireLayer?.getAttribute('width')) || 6000;
            const canvasHeight = parseInt(this.wireLayer?.getAttribute('height')) || 4000;

            snapX = Math.max(0, Math.min(snapX, canvasWidth - compWidth));
            snapY = Math.max(0, Math.min(snapY, canvasHeight - compHeight));

            // ì´ë™ ê±°ë¦¬ ê³„ì‚°
            const currentX = parseFloat(this.dragTarget.style.left) || 0;
            const currentY = parseFloat(this.dragTarget.style.top) || 0;
            const deltaX = snapX - currentX;
            const deltaY = snapY - currentY;

            // ë“œë˜ê·¸ ëŒ€ìƒ ì´ë™
            this.dragTarget.style.left = `${snapX}px`;
            this.dragTarget.style.top = `${snapY}px`;

            // ë‹¤ì¤‘ ì„ íƒëœ ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ë“¤ë„ í•¨ê»˜ ì´ë™ (ì˜ì—­ ì œí•œ ì ìš©)
            if (this.selectedComponents.length > 1 && this.selectedComponents.includes(this.dragTarget)) {
                this.selectedComponents.forEach(comp => {
                    if (comp !== this.dragTarget) {
                        let compX = parseFloat(comp.style.left) || 0;
                        let compY = parseFloat(comp.style.top) || 0;
                        compX = Math.max(0, Math.min(compX + deltaX, canvasWidth - (comp.offsetWidth || 72)));
                        compY = Math.max(0, Math.min(compY + deltaY, canvasHeight - (comp.offsetHeight || 48)));
                        comp.style.left = `${compX}px`;
                        comp.style.top = `${compY}px`;
                    }
                });
            }

            this.redrawWires();
            this.updateStatusBar();
        }

        // D. ì „ì„  ê·¸ë¦¬ê¸° (ì„ì‹œ ì„ )
        // ìŠ¤ëƒ… ë¡œì§ (ë§ˆê·¸ë„¤í‹± íš¨ê³¼)
        if (this.startPin && this.tempLine) {
            const spRect = this.startPin.getBoundingClientRect();
            const startX = (spRect.left + spRect.width / 2 - wsRect.left - this.panX) / this.scale;
            const startY = (spRect.top + spRect.height / 2 - wsRect.top - this.panY) / this.scale;

            let targetX = mouseX;
            let targetY = mouseY;
            this.snappedPin = null;

            // í•€ ìŠ¤ëƒ… ê°ì§€ (Grid ê±°ë¦¬ ê¸°ë°˜)
            const snapThreshold = 15;
            const allPins = document.querySelectorAll('.pin');

            // ê¸°ì¡´ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            allPins.forEach(p => p.classList.remove('snap-target'));

            for (const pin of allPins) {
                if (pin === this.startPin) continue; // ìê¸° ìì‹  ì œì™¸

                const pRect = pin.getBoundingClientRect();
                const px = (pRect.left + pRect.width / 2 - wsRect.left - this.panX) / this.scale;
                const py = (pRect.top + pRect.height / 2 - wsRect.top - this.panY) / this.scale;

                if (Math.hypot(px - mouseX, py - mouseY) < snapThreshold) {
                    targetX = px;
                    targetY = py;
                    this.snappedPin = pin;
                    pin.classList.add('snap-target');
                    break;
                }
            }

            // Orthogonal temp wiring
            const midX = (startX + targetX) / 2;
            let d = `M ${startX} ${startY}`;
            d += ` L ${midX} ${startY} L ${midX} ${targetY} L ${targetX} ${targetY}`;

            this.tempLine.setAttribute('d', d);

            // ìŠ¤ëƒ…ë˜ì—ˆì„ ë•Œ ìƒ‰ìƒ ë³€ê²½
            if (this.snappedPin) {
                this.tempLine.style.stroke = 'var(--accent-secondary)';
                this.tempLine.style.strokeWidth = '3px';
            } else {
                this.tempLine.style.stroke = 'var(--text-muted)';
                this.tempLine.style.strokeWidth = '2px';
            }
        }
    }

    onMouseUp(e) {
        if (this.isPanning) {
            this.isPanning = false;
            this.workspace.style.cursor = 'default';
        }

        try {
            // A. ë“œë˜ê·¸ ì„ íƒ ì¢…ë£Œ
            if (this.isSelecting) {
                this.isSelecting = false;

                // ì¤‘ìš”: rectë¥¼ ë¨¼ì € ê°€ì ¸ì˜¨ í›„ì— ìˆ¨ê²¨ì•¼ í•¨!
                const rect = this.selectionBox.getBoundingClientRect();
                this.selectionBox.style.display = 'none';

                // ì„ íƒ ë°•ìŠ¤ ìµœì†Œ í¬ê¸° í™•ì¸ (5px ì´ìƒì´ì–´ì•¼ ìœ íš¨í•œ ë“œë˜ê·¸ ì„ íƒ)
                const boxWidth = rect.right - rect.left;
                const boxHeight = rect.bottom - rect.top;

                if (boxWidth > 5 && boxHeight > 5) {
                    // ì»´í¬ë„ŒíŠ¸ ì„ íƒ
                    let selectedCount = 0;
                    this.components.forEach(comp => {
                        const compRect = comp.getBoundingClientRect();
                        if (rect.left < compRect.right && rect.right > compRect.left &&
                            rect.top < compRect.bottom && rect.bottom > compRect.top) {
                            this.selectComponent(comp, true);
                            selectedCount++;
                        }
                    });

                    // ì„ íƒëœ ê°œìˆ˜ í”¼ë“œë°±
                    if (selectedCount > 0) {
                        this.showToast(`${selectedCount}ê°œ ì„ íƒë¨`, 'info');
                        this.updateStatusBar();
                    }
                }
            }

            // B. ë¶€í’ˆ ë“œë˜ê·¸ ì¢…ë£Œ (ê²©ì ìŠ¤ëƒ…)
            if (this.dragTarget) {
                const rawLeft = parseFloat(this.dragTarget.style.left);
                const rawTop = parseFloat(this.dragTarget.style.top);
                const snapLeft = Math.round(rawLeft / this.gridSize) * this.gridSize;
                const snapTop = Math.round(rawTop / this.gridSize) * this.gridSize;

                this.dragTarget.style.left = `${snapLeft}px`;
                this.dragTarget.style.top = `${snapTop}px`;

                this.redrawWires();
                this.dragTarget.style.cursor = 'grab';

                // íˆìŠ¤í† ë¦¬ ì €ì¥ (ì´ë™ ì™„ë£Œ)
                this.saveState();
            }

            // C. ì „ì„  ì—°ê²° ë§ˆë¬´ë¦¬ (ìŠ¤ëƒ…ëœ ê²½ìš°)
            if (this.startPin && this.tempLine) {
                // ë§ˆìš°ìŠ¤ ë²„íŠ¼ì„ ë—ì„ ë•Œ ìŠ¤ëƒ…ëœ í•€ì´ ìˆë‹¤ë©´ ì—°ê²°
                if (this.snappedPin) {
                    this.createWire(this.startPin, this.snappedPin);
                    this.cancelWiring();
                }
                // ë¹ˆ ê³µê°„ ë“œë¡­ ì‹œ ì·¨ì†Œ (ë˜ëŠ” JOINT ìƒì„± ë¡œì§ê³¼ ì¶©ëŒ ë°©ì§€)
                else {
                    // ì´ë¯¸ onMouseDownì—ì„œ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ì·¨ì†Œ
                    // í•˜ì§€ë§Œ mousedownê³¼ mouseupì€ ìŒì´ë¯€ë¡œ ì—¬ê¸°ì„œ ì·¨ì†Œí•´ë„ ë¬´ë°©
                    this.cancelWiring();
                }
            }

        } catch (err) {
            console.error("MouseUp Error:", err);
        } finally {
            // [CRITICAL FIX] Ensure drag state is always released
            this.dragTarget = null;
        }
    }

    // ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™” (ë§ˆìš°ìŠ¤ê°€ ì°½ ë°–ìœ¼ë¡œ ë‚˜ê°”ì„ ë•Œ)
    resetDragState() {
        // ë“œë˜ê·¸ ìƒíƒœ í•´ì œ
        if (this.dragTarget) {
            this.dragTarget.style.cursor = 'grab';
            this.dragTarget = null;
        }

        // íŒ¨ë‹ ìƒíƒœ í•´ì œ
        this.isPanning = false;

        // ì„ íƒ ë°•ìŠ¤ ìˆ¨ê¸°ê¸°
        if (this.isSelecting) {
            this.isSelecting = false;
            if (this.selectionBox) {
                this.selectionBox.style.display = 'none';
            }
        }

        // ì„ì‹œ ì™€ì´ì–´ ì·¨ì†Œ
        if (this.startPin && this.tempLine) {
            this.cancelWiring();
        }
    }

    // =========================================================
    // [Section 3] ì „ì„  ì—°ê²° (Wiring)
    // =========================================================
    handlePinClick(pin) {
        if (!this.startPin) {
            // ì‹œì‘ì 
            const role = pin.getAttribute('data-role');
            if (role !== 'output' && this.userMode !== 'expert') {
                return alert("ì¶œë ¥(ì˜¤ë¥¸ìª½) í•€ì—ì„œ ì‹œì‘í•˜ì„¸ìš”!");
            }
            this.startPin = pin;

            this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            this.tempLine.setAttribute('fill', 'none');
            this.tempLine.style.stroke = '#7f8c8d';
            this.tempLine.style.strokeDasharray = "5,5";
            this.wireLayer.appendChild(this.tempLine);
        } else {
            // ë„ì°©ì 
            const role = pin.getAttribute('data-role');
            if (role !== 'input' && this.userMode !== 'expert') {
                this.cancelWiring(); return alert("ì…ë ¥(ì™¼ìª½) í•€ì— ì—°ê²°í•´ì•¼ í•©ë‹ˆë‹¤!");
            }

            if (this.startPin.parentElement === pin.parentElement) {
                this.cancelWiring(); return;
            }

            this.createWire(this.startPin, pin);

            if (pin.parentElement.getAttribute('data-type') === 'JOINT' && this.userMode === 'expert') {
                const joint = pin.parentElement;
                this.cancelWiring();
                this.updateCircuit();

                const newPin = joint.querySelector('.pin');
                this.startPin = newPin;
                this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.tempLine.setAttribute('fill', 'none');
                this.tempLine.style.stroke = '#7f8c8d';
                this.tempLine.style.strokeDasharray = "5,5";
                this.wireLayer.appendChild(this.tempLine);
                return;
            }

            this.cancelWiring();
            this.updateCircuit();
        }
    }

    createWire(pinA, pinB, options = {}) {
        const { skipSave = false, skipRedraw = false } = options;
        // [Safety Check] í•€ì´ ìœ íš¨í•˜ê³  DOMì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        if (!pinA || !pinB || !document.contains(pinA) || !document.contains(pinB)) {
            console.warn("Cannot create wire: Invalid or detached pins");
            return null;
        }

        // Use path for orthogonal routing
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('fill', 'none');
        // pointer-events handled by CSS (#wire-layer path)
        path.classList.add('wire-path');

        // ì „ì„  ë“œë˜ê·¸ ì‹œ JOINT ìƒì„± ë° ì´ë™ (Grab & Pull)
        path.onmousedown = (e) => {
            // íŒ¬ ëª¨ë“œ ë“±ì—ì„œëŠ” ë™ì‘ ì•ˆ í•¨
            if (this.mode !== 'select' && this.mode !== 'edit') return;
            // í™•ì‹¤íˆ pathë¥¼ í´ë¦­í•œ ê²½ìš°ì—ë§Œ
            if (e.target !== path) return;

            e.stopPropagation();
            e.preventDefault();

            // ì¦‰ì‹œ JOINT ìƒì„± í›„ ë“œë˜ê·¸ ëª¨ë“œ ì§„ì…
            const joint = this.insertJointOnWire(pinA, pinB, path, e);
            if (joint) {
                // [CRITICAL] ì§ì ‘ ë“œë˜ê·¸ ìƒíƒœ ì„¤ì • (ì´ë²¤íŠ¸ ì¶©ëŒ ë°©ì§€)
                this.dragTarget = joint;
                this.clearSelection();
                this.selectComponent(joint, true);

                // JOINT ì˜¤í”„ì…‹ (ì¤‘ì•™ ì •ë ¬)
                this.dragOffset = { x: 8, y: 8 };
                joint.style.cursor = 'grabbing';

                // ì¦‰ì‹œ í™”ë©´ ê°±ì‹ 
                requestAnimationFrame(() => this.redrawWires());
            }
        };

        this.wireLayer.appendChild(path);
        const newWire = { from: pinA, to: pinB, line: path };
        this.wires.push(newWire);
        this.redrawWires();
        this.updateStatusBar();
        this.saveState();

        return newWire; // ìƒì„± ì„±ê³µ ì‹œ ê°ì²´ ë°˜í™˜
    }

    // ì „ì„  í´ë¦­ ì‹œ JOINT ì‚½ì… (Returns the new joint component)
    insertJointOnWire(fromPin, toPin, wirePath, event) {
        const wsRect = this.workspace.parentElement.getBoundingClientRect();
        // Safe check for rect
        if (!wsRect || wsRect.width === 0) return null;

        const clickX = (event.clientX - wsRect.left - this.panX) / this.scale;
        const clickY = (event.clientY - wsRect.top - this.panY) / this.scale;

        // ê¸°ì¡´ ì „ì„  ì°¾ê¸° (ì•„ì§ ì§€ìš°ì§€ ì•ŠìŒ)
        const wireIndex = this.wires.findIndex(w => w.line === wirePath);
        if (wireIndex === -1) return null;
        const oldWire = this.wires[wireIndex];

        // 1. JOINT ë¨¼ì € ìƒì„± ì‹œë„
        const joint = this.addModule('JOINT', clickX - 8, clickY - 8);
        if (!joint) {
            console.error("Failed to create JOINT");
            return null;
        }

        const jointPin = joint.querySelector('.pin');
        if (!jointPin) {
            console.error("JOINT has no pin");
            this.removeComponent(joint);
            return null;
        }

        // 2. ìƒˆ ì „ì„  ìƒì„± (Transaction - ì €ì¥/ë¦¬ë“œë¡œìš°ëŠ” ë‚˜ì¤‘ì— í•œ ë²ˆë§Œ)
        let w1 = null, w2 = null;
        try {
            w1 = this.createWire(fromPin, jointPin, { skipSave: true, skipRedraw: true });
            w2 = this.createWire(jointPin, toPin, { skipSave: true, skipRedraw: true });

            // í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì¦‰ì‹œ ë¡¤ë°±
            if (!w1 || !w2) {
                throw new Error("Wire creation failed");
            }
        } catch (e) {
            console.error("Transaction failed, rolling back", e);

            // ë¡¤ë°±: ìƒì„±ëœ ì „ì„  ì œê±°
            if (w1) {
                w1.line.remove();
                const idx = this.wires.indexOf(w1);
                if (idx > -1) this.wires.splice(idx, 1);
            }
            if (w2) {
                w2.line.remove();
                const idx = this.wires.indexOf(w2);
                if (idx > -1) this.wires.splice(idx, 1);
            }

            // ë¡¤ë°±: ìƒì„±ëœ JOINT ì œê±°
            this.removeComponent(joint);
            return null;
        }

        // 3. ëª¨ë“  ìƒì„±ì´ ì„±ê³µí–ˆìœ¼ë©´ ê¸°ì¡´ ì „ì„  ì œê±°
        if (oldWire && oldWire.line) {
            oldWire.line.remove();
        }
        // ì¸ë±ìŠ¤ê°€ ë°”ë€Œì—ˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‹¤ì‹œ ì°¾ê±°ë‚˜(ì•ˆì „), ìœ„ì—ì„œ ì°¾ì€ ì¸ë±ìŠ¤ ì‚¬ìš©(ìœ„í—˜)
        // ì—¬ê¸°ì„  ìœ„ì—ì„œ createWireë¡œ pushë§Œ í–ˆìœ¼ë¯€ë¡œ oldWire ì¸ë±ìŠ¤ëŠ” ê·¸ëŒ€ë¡œì¼ ê²ƒì„.
        // í•˜ì§€ë§Œ ì•ˆì „ì„ ìœ„í•´ ë‹¤ì‹œ ì°¾ìŒ
        const currentWireIndex = this.wires.findIndex(w => w.line === wirePath);
        if (currentWireIndex > -1) {
            this.wires.splice(currentWireIndex, 1);
        }

        this.showToast('ì „ì„  êº¾ì„ (ë“œë˜ê·¸í•˜ì—¬ ì´ë™)', 'info');

        // ë ˆì´ì•„ì›ƒ ì•ˆì •í™” ë° ì‹œê°ì  ì—°ê²° ë³´ì „ì„ ìœ„í•œ ê°•ì œ ì—…ë°ì´íŠ¸
        requestAnimationFrame(() => this.redrawWires());
        // ì´ì¤‘ ì•ˆì „ì¥ì¹˜
        setTimeout(() => this.redrawWires(), 0);

        return joint;
    }

    cancelWiring() {
        // ì„ì‹œ ì„  ì œê±°
        if (this.tempLine) this.tempLine.remove();

        // ì‹œì‘ í•€ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
        if (this.startPin) {
            this.startPin.classList.remove('active');
        }

        // ëª¨ë“  í•€ì˜ ìŠ¤ëƒ… ìŠ¤íƒ€ì¼ ì œê±°
        document.querySelectorAll('.pin.snap-target').forEach(p => p.classList.remove('snap-target'));

        this.startPin = null;
        this.tempLine = null;
        this.snappedPin = null;
    }

    redrawWires() {
        if (!this.workspace || !this.wires) return;

        this.wires.forEach(wire => {
            if (!wire.from || !wire.to || !wire.line) return;

            // [Fix] Use closest to find component reliably (handles complex DOM structures)
            const fromComp = wire.from.closest('.component');
            const toComp = wire.to.closest('.component');

            if (!fromComp || !toComp) return;

            // ì»´í¬ë„ŒíŠ¸ì˜ ëª¨ë¸ ì¢Œí‘œ ì‚¬ìš©
            const fromX = parseFloat(fromComp.style.left) || 0;
            const fromY = parseFloat(fromComp.style.top) || 0;
            const toX = parseFloat(toComp.style.left) || 0;
            const toY = parseFloat(toComp.style.top) || 0;

            // í•€ ì˜¤í”„ì…‹ ê³„ì‚° (ì»´í¬ë„ŒíŠ¸ ê¸°ì¤€)
            let fromPinOffsetX = 0, fromPinOffsetY = 0, toPinOffsetX = 0, toPinOffsetY = 0;

            try {
                // [Optimization] JOINT (size 16x16) -> Offset 8,8
                if (fromComp.getAttribute('data-type') === 'JOINT') {
                    fromPinOffsetX = 8; fromPinOffsetY = 8;
                } else {
                    const fromPinRect = wire.from.getBoundingClientRect();
                    const fromCompRect = fromComp.getBoundingClientRect();
                    fromPinOffsetX = (fromPinRect.left - fromCompRect.left + fromPinRect.width / 2) / this.scale;
                    fromPinOffsetY = (fromPinRect.top - fromCompRect.top + fromPinRect.height / 2) / this.scale;
                }

                if (toComp.getAttribute('data-type') === 'JOINT') {
                    toPinOffsetX = 8; toPinOffsetY = 8;
                } else {
                    const toPinRect = wire.to.getBoundingClientRect();
                    const toCompRect = toComp.getBoundingClientRect();
                    toPinOffsetX = (toPinRect.left - toCompRect.left + toPinRect.width / 2) / this.scale;
                    toPinOffsetY = (toPinRect.top - toCompRect.top + toPinRect.height / 2) / this.scale;
                }
            } catch (e) {
                // DOM ê³„ì‚° ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’ (ì¤‘ì•™)
                fromPinOffsetX = 20; fromPinOffsetY = 20;
                toPinOffsetX = 20; toPinOffsetY = 20;
            }

            // ìµœì¢… ì™€ì´ì–´ ì¢Œí‘œ
            const x1 = fromX + fromPinOffsetX;
            const y1 = fromY + fromPinOffsetY;
            const x2 = toX + toPinOffsetX;
            const y2 = toY + toPinOffsetY;

            // Orthogonal Routing
            const midX = (x1 + x2) / 2;
            let d = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;

            wire.line.setAttribute('d', d);

            // ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì „ë¥˜ íë¦„)
            const isActive = fromComp.getAttribute('data-value') === '1';
            if (isActive) {
                wire.line.classList.add('active-flow');
                wire.line.style.stroke = 'var(--signal-high)';
            } else {
                wire.line.classList.remove('active-flow');
                wire.line.style.stroke = 'var(--signal-low)';
            }
        });
    }

    // í†µí•© ëª¨ë“œ - ì´ í•¨ìˆ˜ë“¤ì€ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ë˜ì§€ë§Œ ì‹¤ì œ ë™ì‘ì€ ì—†ìŒ
    setUserMode(mode) {
        this.userMode = 'expert'; // í•­ìƒ expert ëª¨ë“œ
        this.resizeCanvas();
    }

    // handlePinClick ì´ì „ì˜ ë¹ˆ ê³µê°„ ìœ ì§€
    // í•€ í´ë¦­ í•¸ë“¤ëŸ¬ (ì „ì„  ì—°ê²°ìš©)
    handlePinClick(pin) {
        if (!this.startPin) {
            // ì²« ë²ˆì§¸ í•€ í´ë¦­ - ì „ì„  ì‹œì‘
            this.startPin = pin;
            pin.classList.add('active');
        } else {
            // ë‘ ë²ˆì§¸ í•€ í´ë¦­ - ì „ì„  ì—°ê²° ì™„ë£Œ
            if (this.startPin !== pin) {
                this.createWire(this.startPin, pin);
                this.updateCircuit();
            }
            this.cancelWiring();
        }
    }

    addPackage(pkgType) {
        // íŒ¨í‚¤ì§€ ì¶”ê°€ - ë‚´ë¶€ íšŒë¡œë¥¼ ê°–ëŠ” ë³µí•© ì»´í¬ë„ŒíŠ¸
        const pkgDefs = {
            'HALF_ADDER': {
                label: 'HA',
                name: 'Half Adder',
                inputs: ['A', 'B'],
                outputs: ['S', 'C'],
                color: '#16a085',
                // ë‚´ë¶€ íšŒë¡œ: XOR (Sum) + AND (Carry)
                circuit: {
                    components: [
                        { id: 'xor1', type: 'XOR', x: 60, y: 20, label: 'XOR' },
                        { id: 'and1', type: 'AND', x: 60, y: 80, label: 'AND' },
                        { id: 'in_a', type: 'PORT_IN', x: 10, y: 30, label: 'A' },
                        { id: 'in_b', type: 'PORT_IN', x: 10, y: 70, label: 'B' },
                        { id: 'out_s', type: 'PORT_OUT', x: 140, y: 30, label: 'S' },
                        { id: 'out_c', type: 'PORT_OUT', x: 140, y: 90, label: 'C' }
                    ],
                    wires: [
                        { from: 'in_a', fromPin: 'out', to: 'xor1', toPin: 'in-1' },
                        { from: 'in_b', fromPin: 'out', to: 'xor1', toPin: 'in-2' },
                        { from: 'in_a', fromPin: 'out', to: 'and1', toPin: 'in-1' },
                        { from: 'in_b', fromPin: 'out', to: 'and1', toPin: 'in-2' },
                        { from: 'xor1', fromPin: 'out', to: 'out_s', toPin: 'in' },
                        { from: 'and1', fromPin: 'out', to: 'out_c', toPin: 'in' }
                    ]
                },
                // ì‹œë®¬ë ˆì´ì…˜ ë¡œì§
                logic: (inputs) => {
                    const a = inputs[0], b = inputs[1];
                    return { S: a !== b ? 1 : 0, C: (a && b) ? 1 : 0 };
                }
            },
            'FULL_ADDER': {
                label: 'FA',
                name: 'Full Adder',
                inputs: ['A', 'B', 'Cin'],
                outputs: ['S', 'Cout'],
                color: '#27ae60',
                // ë‚´ë¶€ íšŒë¡œ: 2 x Half Adder + OR
                circuit: {
                    components: [
                        { id: 'xor1', type: 'XOR', x: 50, y: 20, label: 'XOR1' },
                        { id: 'xor2', type: 'XOR', x: 120, y: 30, label: 'XOR2' },
                        { id: 'and1', type: 'AND', x: 50, y: 80, label: 'AND1' },
                        { id: 'and2', type: 'AND', x: 120, y: 100, label: 'AND2' },
                        { id: 'or1', type: 'OR', x: 190, y: 90, label: 'OR' },
                        { id: 'in_a', type: 'PORT_IN', x: 10, y: 20, label: 'A' },
                        { id: 'in_b', type: 'PORT_IN', x: 10, y: 60, label: 'B' },
                        { id: 'in_cin', type: 'PORT_IN', x: 10, y: 100, label: 'Cin' },
                        { id: 'out_s', type: 'PORT_OUT', x: 200, y: 30, label: 'S' },
                        { id: 'out_cout', type: 'PORT_OUT', x: 260, y: 90, label: 'Cout' }
                    ],
                    wires: [
                        { from: 'in_a', fromPin: 'out', to: 'xor1', toPin: 'in-1' },
                        { from: 'in_b', fromPin: 'out', to: 'xor1', toPin: 'in-2' },
                        { from: 'xor1', fromPin: 'out', to: 'xor2', toPin: 'in-1' },
                        { from: 'in_cin', fromPin: 'out', to: 'xor2', toPin: 'in-2' },
                        { from: 'in_a', fromPin: 'out', to: 'and1', toPin: 'in-1' },
                        { from: 'in_b', fromPin: 'out', to: 'and1', toPin: 'in-2' },
                        { from: 'xor1', fromPin: 'out', to: 'and2', toPin: 'in-1' },
                        { from: 'in_cin', fromPin: 'out', to: 'and2', toPin: 'in-2' },
                        { from: 'and1', fromPin: 'out', to: 'or1', toPin: 'in-1' },
                        { from: 'and2', fromPin: 'out', to: 'or1', toPin: 'in-2' },
                        { from: 'xor2', fromPin: 'out', to: 'out_s', toPin: 'in' },
                        { from: 'or1', fromPin: 'out', to: 'out_cout', toPin: 'in' }
                    ]
                },
                logic: (inputs) => {
                    const a = inputs[0], b = inputs[1], cin = inputs[2];
                    const sum = (a ? 1 : 0) + (b ? 1 : 0) + (cin ? 1 : 0);
                    return { S: sum % 2, Cout: sum >= 2 ? 1 : 0 };
                }
            },
            'SR_LATCH': {
                label: 'SR',
                name: 'SR Latch',
                inputs: ['S', 'R'],
                outputs: ['Q', 'QÌ…'],
                color: '#2980b9',
                circuit: {
                    components: [
                        { id: 'nor1', type: 'NOR', x: 60, y: 20, label: 'NOR1' },
                        { id: 'nor2', type: 'NOR', x: 60, y: 80, label: 'NOR2' },
                        { id: 'in_s', type: 'PORT_IN', x: 10, y: 20, label: 'S' },
                        { id: 'in_r', type: 'PORT_IN', x: 10, y: 80, label: 'R' },
                        { id: 'out_q', type: 'PORT_OUT', x: 140, y: 20, label: 'Q' },
                        { id: 'out_qn', type: 'PORT_OUT', x: 140, y: 80, label: 'QÌ…' }
                    ],
                    wires: [
                        { from: 'in_s', fromPin: 'out', to: 'nor1', toPin: 'in-1' },
                        { from: 'nor2', fromPin: 'out', to: 'nor1', toPin: 'in-2' },
                        { from: 'in_r', fromPin: 'out', to: 'nor2', toPin: 'in-2' },
                        { from: 'nor1', fromPin: 'out', to: 'nor2', toPin: 'in-1' },
                        { from: 'nor1', fromPin: 'out', to: 'out_q', toPin: 'in' },
                        { from: 'nor2', fromPin: 'out', to: 'out_qn', toPin: 'in' }
                    ]
                },
                logic: (inputs, state) => ({ Q: state?.Q || 0, 'QÌ…': state?.['QÌ…'] || 1 })
            },
            'D_FLIPFLOP': {
                label: 'DFF',
                name: 'D Flip-Flop',
                inputs: ['D', 'CLK'],
                outputs: ['Q', 'QÌ…'],
                color: '#8e44ad',
                logic: (inputs, state) => {
                    // í´ëŸ­ ìƒìŠ¹ ì—ì§€ì—ì„œë§Œ ì €ì¥
                    return { Q: state?.Q || 0, 'QÌ…': state?.Q ? 0 : 1 };
                }
            }
        };

        const pkg = pkgDefs[pkgType];
        if (!pkg) {
            alert('ì•Œ ìˆ˜ ì—†ëŠ” íŒ¨í‚¤ì§€: ' + pkgType);
            return;
        }

        // íŒ¨í‚¤ì§€ ì»´í¬ë„ŒíŠ¸ ìƒì„±
        const el = document.createElement('div');
        el.classList.add('component', 'package-comp');
        el.id = 'pkg_' + Date.now() + Math.random().toString(36).substr(2, 5);
        el.setAttribute('data-type', pkgType);
        el.setAttribute('data-value', '0');

        const inputCount = pkg.inputs.length;
        const outputCount = pkg.outputs.length;
        const maxPins = Math.max(inputCount, outputCount);

        el.style.width = '100px';
        el.style.height = (30 + maxPins * 22) + 'px';
        el.style.background = `linear-gradient(135deg, ${pkg.color} 0%, ${this.darkenColorSimple(pkg.color, 25)} 100%)`;
        el.style.borderRadius = '8px';
        el.style.border = '2px solid rgba(255,255,255,0.3)';
        el.style.boxShadow = `0 4px 15px ${pkg.color}66`;

        // ë¼ë²¨
        const label = document.createElement('div');
        label.classList.add('comp-label');
        label.innerText = pkg.label;
        label.style.color = 'white';
        label.style.fontWeight = 'bold';
        label.style.fontSize = '14px';
        label.style.textShadow = '0 1px 3px rgba(0,0,0,0.5)';
        el.appendChild(label);

        // ì…ë ¥ í•€ (ì™¼ìª½)
        const height = 30 + maxPins * 22;
        pkg.inputs.forEach((name, i) => {
            const pin = document.createElement('div');
            pin.classList.add('pin', 'input', `in${i}`);
            const spacing = height / (inputCount + 1);
            pin.style.left = '-6px';
            pin.style.top = (spacing * (i + 1)) + 'px';
            pin.setAttribute('data-pinid', 'in_' + i);
            pin.setAttribute('data-label', name);
            pin.setAttribute('title', name);
            pin.onclick = (e) => { e.stopPropagation(); this.handlePinClick(pin); };
            el.appendChild(pin);
        });

        // ì¶œë ¥ í•€ (ì˜¤ë¥¸ìª½)
        pkg.outputs.forEach((name, i) => {
            const pin = document.createElement('div');
            pin.classList.add('pin', 'output', `out${i}`);
            const spacing = height / (outputCount + 1);
            pin.style.right = '-6px';
            pin.style.left = 'auto';
            pin.style.top = (spacing * (i + 1)) + 'px';
            pin.setAttribute('data-pinid', 'out_' + i);
            pin.setAttribute('data-label', name);
            pin.setAttribute('title', name);
            pin.onclick = (e) => { e.stopPropagation(); this.handlePinClick(pin); };
            el.appendChild(pin);
        });

        // ìœ„ì¹˜ ì„¤ì •
        const spawnX = (-this.panX + 300 + Math.random() * 50) / this.scale;
        const spawnY = (-this.panY + 200 + Math.random() * 50) / this.scale;
        el.style.left = spawnX + 'px';
        el.style.top = spawnY + 'px';

        // ë‚´ë¶€ íšŒë¡œ ì •ë³´ ì €ì¥
        el.internals = pkg.circuit ? this.buildPackageInternals(el, pkg) : null;
        el.pkgDef = pkg;

        // ì´ë²¤íŠ¸
        el.onmousedown = (e) => this.handleComponentMouseDown(e, el);
        el.onmouseenter = () => this.showTooltip(pkg.name || pkgType);
        el.onmouseleave = () => this.hideTooltip();
        el.oncontextmenu = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!this.selectedComponents.includes(el)) {
                this.selectComponent(el, false);
            }
            this.showContextMenu(e.clientX, e.clientY);
        };

        // ë”ë¸”í´ë¦­ ì‹œ ë‚´ë¶€ íšŒë¡œ ë³´ê¸°
        el.ondblclick = (e) => {
            e.stopPropagation();
            if (el.internals || pkg.circuit) {
                this.enterComponent(el);
            }
        };

        this.workspace.appendChild(el);
        this.components.push(el);
        this.saveState();
    }

    // ìƒ‰ìƒ ì–´ë‘¡ê²Œ (ê°„ë‹¨ ë²„ì „)
    darkenColorSimple(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max((num >> 16) - amt, 0);
        const G = Math.max((num >> 8 & 0x00FF) - amt, 0);
        const B = Math.max((num & 0x0000FF) - amt, 0);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }

    // íŒ¨í‚¤ì§€ ë‚´ë¶€ íšŒë¡œ ë¹Œë“œ
    buildPackageInternals(parentComp, pkg) {
        if (!pkg.circuit) return null;

        const internals = { components: [], wires: [] };
        const idMap = {};

        pkg.circuit.components.forEach(part => {
            const el = document.createElement('div');
            el.classList.add('component');
            el.id = parentComp.id + '_' + part.id;
            el.setAttribute('data-type', part.type);
            el.setAttribute('data-value', '0');
            el.style.left = part.x + 'px';
            el.style.top = part.y + 'px';

            const label = document.createElement('div');
            label.classList.add('comp-label');
            label.innerText = part.label || part.type;
            el.appendChild(label);

            // í•€ ì¶”ê°€
            if (['AND', 'OR', 'NAND', 'NOR', 'XOR', 'XNOR'].includes(part.type)) {
                this.addPin(el, 'in-1', 'input in-1');
                this.addPin(el, 'in-2', 'input in-2');
                this.addPin(el, 'out', 'output center');
            } else if (part.type === 'NOT') {
                this.addPin(el, 'in-1', 'input center');
                this.addPin(el, 'out', 'output center');
            } else if (part.type === 'PORT_IN') {
                this.addPin(el, 'out', 'output center');
            } else if (part.type === 'PORT_OUT') {
                this.addPin(el, 'in', 'input center');
            }

            idMap[part.id] = el;
            internals.components.push(el);
        });

        // ì™€ì´ì–´ ìƒì„± (line SVG ìš”ì†Œ í¬í•¨)
        pkg.circuit.wires.forEach(wire => {
            const fromEl = idMap[wire.from];
            const toEl = idMap[wire.to];
            if (fromEl && toEl) {
                const fromPin = fromEl.querySelector(`.${wire.fromPin}`) || fromEl.querySelector('.output') || fromEl.querySelector('.out');
                const toPin = toEl.querySelector(`.${wire.toPin}`) || toEl.querySelector('.input') || toEl.querySelector('.in');
                if (fromPin && toPin) {
                    // SVG ë¼ì¸ ìš”ì†Œ ìƒì„±
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    line.setAttribute('stroke', '#64748b');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('fill', 'none');
                    internals.wires.push({ from: fromPin, to: toPin, fromEl, toEl, line });
                }
            }
        });

        return internals;
    }

    createPackage() {
        if (this.selectedComponents.length === 0) {
            alert('íŒ¨í‚¤ì§€ë¡œ ë§Œë“¤ ë¶€í’ˆë“¤ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.\n(Ctrl+í´ë¦­ ë˜ëŠ” ë“œë˜ê·¸ë¡œ ë‹¤ì¤‘ ì„ íƒ)');
            return;
        }

        // 1. ì„ íƒëœ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ ID ìˆ˜ì§‘
        const selectedIds = new Set(this.selectedComponents.map(c => c.id));

        // 2. ë‚´ë¶€/ì™¸ë¶€ ì „ì„  ë¶„ë¥˜
        const internalWires = [];
        const externalInputs = [];
        const externalOutputs = [];

        this.wires.forEach(wire => {
            const fromComp = wire.from.closest('.component');
            const toComp = wire.to.closest('.component');
            const fromId = fromComp?.id;
            const toId = toComp?.id;
            const fromInside = selectedIds.has(fromId);
            const toInside = selectedIds.has(toId);

            if (fromInside && toInside) {
                internalWires.push({ fromId, toId, fromPin: wire.from.className, toPin: wire.to.className });
            } else if (!fromInside && toInside) {
                externalInputs.push({ targetId: toId, targetPin: wire.to.className, label: `IN${externalInputs.length + 1}` });
            } else if (fromInside && !toInside) {
                externalOutputs.push({ sourceId: fromId, sourcePin: wire.from.className, label: `OUT${externalOutputs.length + 1}` });
            }
        });

        // 3. ìœ„ì¹˜ ì •ê·œí™”
        let minX = Infinity, minY = Infinity;
        this.selectedComponents.forEach(c => {
            minX = Math.min(minX, parseFloat(c.style.left));
            minY = Math.min(minY, parseFloat(c.style.top));
        });

        // 4. íšŒë¡œ ë°ì´í„° êµ¬ì„±
        const circuitData = {
            components: this.selectedComponents.map(c => ({
                id: c.id,
                type: c.getAttribute('data-type'),
                value: c.getAttribute('data-value') || '0',
                x: parseFloat(c.style.left) - minX,
                y: parseFloat(c.style.top) - minY,
                width: parseFloat(c.style.width) || 80,
                height: parseFloat(c.style.height) || 56
            })),
            wires: internalWires,
            inputs: externalInputs,
            outputs: externalOutputs
        };

        // 5. íŒ¨í‚¤ì§€ ë””ìì´ë„ˆ ì°½ ì—´ê¸°
        const designerWindow = window.open(
            'package-designer.html',
            'PackageDesigner',
            'width=1200,height=800,menubar=no,toolbar=no,location=no'
        );

        // 6. ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì„¤ì •
        const self = this;
        const messageHandler = (event) => {
            if (event.data.type === 'DESIGNER_READY') {
                setTimeout(() => {
                    designerWindow.postMessage({
                        type: 'CIRCUIT_DATA',
                        data: circuitData
                    }, '*');
                }, 100);
            } else if (event.data.type === 'PACKAGE_CREATED') {
                self.onPackageCreated(event.data.data);
                window.removeEventListener('message', messageHandler);
            }
        };
        window.addEventListener('message', messageHandler);
    }

    onPackageCreated(pkgData) {
        this.userPackages.push(pkgData);
        this.saveUserPackages(); // localStorageì— ì €ì¥
        this.updatePackageList();
        this.showToast(`íŒ¨í‚¤ì§€ "${pkgData.name}"ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
    }

    // createBuiltInPackages í•¨ìˆ˜ ì œê±°ë¨ - ë…¼ë¦¬ ê²Œì´íŠ¸ëŠ” addModule()ë¡œ ì¶”ê°€ë¨

    // localStorageì—ì„œ ì‚¬ìš©ì íŒ¨í‚¤ì§€ ë¡œë“œ
    loadUserPackages() {
        try {
            const saved = localStorage.getItem('logic_sim_user_packages');
            if (saved) {
                this.userPackages = JSON.parse(saved);
                console.log(`âœ… ${this.userPackages.length}ê°œì˜ ì‚¬ìš©ì íŒ¨í‚¤ì§€ ë¡œë“œë¨`);
                // DOMì´ ì¤€ë¹„ëœ í›„ UI ì—…ë°ì´íŠ¸
                setTimeout(() => this.updatePackageList(), 0);
            }
        } catch (e) {
            console.warn('íŒ¨í‚¤ì§€ ë¡œë“œ ì‹¤íŒ¨:', e);
            this.userPackages = [];
        }
    }

    // ì‚¬ìš©ì íŒ¨í‚¤ì§€ë¥¼ localStorageì— ì €ì¥
    saveUserPackages() {
        try {
            // circuit ë°ì´í„°ì—ì„œ DOM ì°¸ì¡° ì œê±° (ì§ë ¬í™” ê°€ëŠ¥í•˜ê²Œ)
            const serializable = this.userPackages.map(pkg => ({
                name: pkg.name,
                desc: pkg.desc || '',
                inputs: pkg.inputs,
                outputs: pkg.outputs,
                width: pkg.width,
                height: pkg.height,
                circuit: pkg.circuit ? {
                    components: pkg.circuit.components,
                    wires: pkg.circuit.wires?.map(w => ({
                        fromId: w.fromId,
                        toId: w.toId,
                        fromPin: w.fromPin,
                        toPin: w.toPin
                    })) || []
                } : null
            }));
            localStorage.setItem('logic_sim_user_packages', JSON.stringify(serializable));
            console.log(`ğŸ’¾ ${this.userPackages.length}ê°œì˜ íŒ¨í‚¤ì§€ ì €ì¥ë¨`);
        } catch (e) {
            console.warn('íŒ¨í‚¤ì§€ ì €ì¥ ì‹¤íŒ¨:', e);
        }
    }

    updatePackageList() {
        const container = document.getElementById('user-packages');
        if (!container) return;

        if (this.userPackages.length === 0) {
            container.innerHTML = '';
        } else {
            container.innerHTML = this.userPackages.map((pkg, i) =>
                `<button class="comp-btn package wide" onclick="sim.addUserPackage(${i})" 
                    onmouseenter="sim.showTooltip('PACKAGE'); sim.positionTooltip(event)"
                    onmouseleave="sim.hideTooltip()">
                    <div class="icon"><svg><use href="#icon-package" /></svg></div>
                    <span class="name">${pkg.name}</span>
                    <span class="pkg-info">${pkg.inputs.length}â†’${pkg.outputs.length}</span>
                </button>`
            ).join('');
        }
    }

    addUserPackage(index) {
        const pkg = this.userPackages[index];
        if (!pkg) return;

        // íŒ¨í‚¤ì§€ë¥¼ ìº”ë²„ìŠ¤ ì¤‘ì•™ì— ë°°ì¹˜
        const scale = this.scale || 1.0;
        const panX = this.panX || 0;
        const panY = this.panY || 0;
        const x = (-panX + 300) / scale;
        const y = (-panY + 200) / scale;

        const el = document.createElement('div');
        el.className = 'component module package-component';
        el.setAttribute('data-type', 'PACKAGE');
        el.setAttribute('data-package-id', String(index));
        el.setAttribute('data-value', '0');
        el.id = 'pkg_' + Date.now() + Math.random().toString(36).substr(2, 5);

        // í¬ê¸° ê³„ì‚° (í•€ ê°œìˆ˜ì— ë”°ë¼ ë™ì )
        const inputCount = pkg.inputs?.length || 0;
        const outputCount = pkg.outputs?.length || 0;
        const maxPins = Math.max(inputCount, outputCount, 1);
        const width = Math.max(120, pkg.width || 120);
        const height = Math.max(80, maxPins * 30 + 40);

        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.width = width + 'px';
        el.style.height = height + 'px';
        el.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        el.style.border = '2px solid rgba(255,255,255,0.3)';
        el.style.borderRadius = '8px';
        el.style.position = 'absolute';
        el.style.cursor = 'move';
        el.style.boxShadow = '0 4px 20px rgba(102, 126, 234, 0.4)';

        // ë¼ë²¨
        const label = document.createElement('div');
        label.className = 'comp-label';
        label.innerText = pkg.name || 'Package';
        label.style.fontSize = '12px';
        label.style.fontWeight = 'bold';
        label.style.color = 'white';
        label.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
        el.appendChild(label);

        // ì…ë ¥ í•€ë“¤ (ì™¼ìª½)
        if (pkg.inputs && pkg.inputs.length > 0) {
            pkg.inputs.forEach((input, i) => {
                const spacing = height / (pkg.inputs.length + 1);
                this.addPin(el, `in${i}`, `input left`, spacing * (i + 1) - height / 2);
            });
        }

        // ì¶œë ¥ í•€ë“¤ (ì˜¤ë¥¸ìª½)
        if (pkg.outputs && pkg.outputs.length > 0) {
            pkg.outputs.forEach((output, i) => {
                const spacing = height / (pkg.outputs.length + 1);
                this.addPin(el, `out${i}`, `output right`, spacing * (i + 1) - height / 2);
            });
        }

        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì—°ê²°
        el.onmousedown = (e) => this.handleComponentMouseDown(e, el);
        el.onmouseenter = () => this.showTooltip('PACKAGE');
        el.onmouseleave = () => this.hideTooltip();
        el.oncontextmenu = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!this.selectedComponents.includes(el)) {
                this.selectComponent(el, false);
            }
            this.showContextMenu(e.clientX, e.clientY);
        };

        // workspaceì— ì¶”ê°€
        if (this.workspace) {
            this.workspace.appendChild(el);
            this.components.push(el);
        }

        this.saveState();
        return el;
    }

    // addBuiltInPackage í•¨ìˆ˜ ì œê±°ë¨ - ë…¼ë¦¬ ê²Œì´íŠ¸ëŠ” addModule()ë¡œ ì¶”ê°€ë¨

    // ì‚¬ìš©ì ëª¨ë“œ ì „í™˜ - í†µí•© ëª¨ë“œë¡œ ì¸í•´ ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
    // (í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ëŠ” ìœ ì§€)
    toggleUserMode() {
        // ëª¨ë“  ê¸°ëŠ¥ì´ í•­ìƒ í™œì„±í™”ë˜ì–´ ìˆìŒ
        console.log('í†µí•© ëª¨ë“œ: ëª¨ë“  ê¸°ëŠ¥ì´ í•­ìƒ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.');
    }

    // =========================================================
    // [Section 4] ê³ ê¸‰ ê¸°ëŠ¥ (ì„ íƒ, ë³µì‚¬, ìš°í´ë¦­, ë‹¨ì¶•í‚¤)
    // =========================================================
    selectComponent(el, keepOthers) {
        if (!keepOthers) this.clearSelection();
        if (!this.selectedComponents.includes(el)) {
            this.selectedComponents.push(el);
            el.classList.add('selected'); // CSS: ë…¸ë€ í…Œë‘ë¦¬
        }
        this.updateSelectionIndicator();
        // [Modified] ì†ì„± íŒ¨ë„ ìë™ í‘œì‹œ ì œê±°
        this.hideComponentInfoPanel();
        /*
        // ë‹¨ì¼ ì„ íƒ ì‹œ ì„¤ëª…ì°½ ì—…ë°ì´íŠ¸
        if (this.selectedComponents.length === 1) {
            this.updateComponentInfoPanel(el);
        } else {
            this.hideComponentInfoPanel();
        }
        */
    }

    clearSelection() {
        this.selectedComponents.forEach(el => el.classList.remove('selected'));
        this.selectedComponents = [];
        this.updateSelectionIndicator();
        this.hideComponentInfoPanel();
    }

    // ì„ íƒ ìƒíƒœ í‘œì‹œê¸° ì—…ë°ì´íŠ¸
    updateSelectionIndicator() {
        const indicator = document.getElementById('selection-count');
        if (indicator) {
            if (this.selectedComponents.length > 0) {
                indicator.textContent = `ì„ íƒ: ${this.selectedComponents.length}ê°œ`;
                indicator.style.display = 'inline-block';
            } else {
                indicator.style.display = 'none';
            }
        }
    }
    showContextMenu(x, y) {
        if (!this.contextMenu) return;
        this.contextMenu.style.display = 'block';
        this.contextMenu.style.top = y + 'px';
    }

    hideContextMenu() {
        if (!this.contextMenu) return;
        this.contextMenu.style.display = 'none';
    }

    // =========================================================
    // [Section 4-1] ì†Œì ì„¤ëª…ì°½ (Component Info Panel)
    // =========================================================

    // ì†Œì ìœ í˜•ë³„ ì •ë³´ ë°ì´í„°
    getComponentInfo(type) {
        const componentData = {
            'AND': {
                icon: 'âŠ—',
                name: 'AND ê²Œì´íŠ¸',
                description: 'ë‘ ì…ë ¥ì´ ëª¨ë‘ HIGHì¼ ë•Œë§Œ ì¶œë ¥ì´ HIGHê°€ ë©ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: [
                    ['0', '0', '0'],
                    ['0', '1', '0'],
                    ['1', '0', '0'],
                    ['1', '1', '1']
                ]
            },
            'OR': {
                icon: 'âŠ•',
                name: 'OR ê²Œì´íŠ¸',
                description: 'ì…ë ¥ ì¤‘ í•˜ë‚˜ë¼ë„ HIGHì´ë©´ ì¶œë ¥ì´ HIGHê°€ ë©ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: [
                    ['0', '0', '0'],
                    ['0', '1', '1'],
                    ['1', '0', '1'],
                    ['1', '1', '1']
                ]
            },
            'NOT': {
                icon: 'Â¬',
                name: 'NOT ê²Œì´íŠ¸ (ì¸ë²„í„°)',
                description: 'ì…ë ¥ ì‹ í˜¸ë¥¼ ë°˜ì „ì‹œí‚µë‹ˆë‹¤. HIGHâ†’LOW, LOWâ†’HIGH',
                inputs: 1,
                outputs: 1,
                truthTable: [
                    ['0', '1'],
                    ['1', '0']
                ]
            },
            'XOR': {
                icon: 'âŠ»',
                name: 'XOR ê²Œì´íŠ¸',
                description: 'ë‘ ì…ë ¥ì´ ì„œë¡œ ë‹¤ë¥¼ ë•Œë§Œ ì¶œë ¥ì´ HIGHê°€ ë©ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: [
                    ['0', '0', '0'],
                    ['0', '1', '1'],
                    ['1', '0', '1'],
                    ['1', '1', '0']
                ]
            },
            'NAND': {
                icon: 'âŠ¼',
                name: 'NAND ê²Œì´íŠ¸',
                description: 'AND ê²Œì´íŠ¸ì˜ ì¶œë ¥ì„ ë°˜ì „ì‹œí‚µë‹ˆë‹¤. ë²”ìš© ê²Œì´íŠ¸ì…ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: [
                    ['0', '0', '1'],
                    ['0', '1', '1'],
                    ['1', '0', '1'],
                    ['1', '1', '0']
                ]
            },
            'NOR': {
                icon: 'âŠ½',
                name: 'NOR ê²Œì´íŠ¸',
                description: 'OR ê²Œì´íŠ¸ì˜ ì¶œë ¥ì„ ë°˜ì „ì‹œí‚µë‹ˆë‹¤. ë²”ìš© ê²Œì´íŠ¸ì…ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: [
                    ['0', '0', '1'],
                    ['0', '1', '0'],
                    ['1', '0', '0'],
                    ['1', '1', '0']
                ]
            },
            'XNOR': {
                icon: 'âŠ™',
                name: 'XNOR ê²Œì´íŠ¸',
                description: 'XOR ê²Œì´íŠ¸ì˜ ì¶œë ¥ì„ ë°˜ì „ì‹œí‚µë‹ˆë‹¤. ì¼ì¹˜ ê²€ì¶œê¸°',
                inputs: 2,
                outputs: 1,
                truthTable: [
                    ['0', '0', '1'],
                    ['0', '1', '0'],
                    ['1', '0', '0'],
                    ['1', '1', '1']
                ]
            },
            'SWITCH': {
                icon: 'ğŸ”˜',
                name: 'ìŠ¤ìœ„ì¹˜',
                description: 'í´ë¦­í•˜ì—¬ ON/OFFë¥¼ ì „í™˜í•©ë‹ˆë‹¤. ì…ë ¥ ì‹ í˜¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.',
                inputs: 0,
                outputs: 1,
                truthTable: null
            },
            'LED': {
                icon: 'ğŸ’¡',
                name: 'LED',
                description: 'ì…ë ¥ ì‹ í˜¸ê°€ HIGHì¼ ë•Œ ë¶ˆì´ ì¼œì§‘ë‹ˆë‹¤.',
                inputs: 1,
                outputs: 0,
                truthTable: null
            },
            'CLOCK': {
                icon: 'â°',
                name: 'í´ëŸ­',
                description: 'ì¼ì • ì£¼ê¸°ë¡œ HIGH/LOW ì‹ í˜¸ë¥¼ êµëŒ€ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.',
                inputs: 0,
                outputs: 1,
                truthTable: null
            },
            'JOINT': {
                icon: 'âš«',
                name: 'ì—°ê²°ì ',
                description: 'ì—¬ëŸ¬ ì™€ì´ì–´ë¥¼ ì—°ê²°í•˜ëŠ” ë¶„ê¸°ì ì…ë‹ˆë‹¤.',
                inputs: 1,
                outputs: 1,
                truthTable: null
            },
            'TRANSISTOR': {
                icon: 'ğŸ“',
                name: 'NMOS íŠ¸ëœì§€ìŠ¤í„°',
                description: 'ê²Œì´íŠ¸ê°€ HIGHì¼ ë•Œ ë“œë ˆì¸-ì†ŒìŠ¤ê°€ ì—°ê²°ë©ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: null
            },
            'PMOS': {
                icon: 'ğŸ“Œ',
                name: 'PMOS íŠ¸ëœì§€ìŠ¤í„°',
                description: 'ê²Œì´íŠ¸ê°€ LOWì¼ ë•Œ ë“œë ˆì¸-ì†ŒìŠ¤ê°€ ì—°ê²°ë©ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 1,
                truthTable: null
            },
            'VCC': {
                icon: 'â¬†ï¸',
                name: 'VCC (ì „ì›)',
                description: 'í•­ìƒ HIGH(1) ì‹ í˜¸ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.',
                inputs: 0,
                outputs: 1,
                truthTable: null
            },
            'GND': {
                icon: 'â¬‡ï¸',
                name: 'GND (ì ‘ì§€)',
                description: 'í•­ìƒ LOW(0) ì‹ í˜¸ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.',
                inputs: 0,
                outputs: 1,
                truthTable: null
            },
            'HALF_ADDER': {
                icon: 'â•',
                name: 'Half Adder (ë°˜ê°€ì‚°ê¸°)',
                description: 'ë‘ ë¹„íŠ¸ë¥¼ ë”í•©ë‹ˆë‹¤. Sumê³¼ Carry ì¶œë ¥ì„ ê°€ì§‘ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 2,
                truthTable: [
                    ['0', '0', '0', '0'],
                    ['0', '1', '1', '0'],
                    ['1', '0', '1', '0'],
                    ['1', '1', '0', '1']
                ],
                headers: ['A', 'B', 'Sum', 'Carry']
            },
            'FULL_ADDER': {
                icon: 'â•',
                name: 'Full Adder (ì „ê°€ì‚°ê¸°)',
                description: 'ì„¸ ë¹„íŠ¸(A, B, Cin)ë¥¼ ë”í•©ë‹ˆë‹¤.',
                inputs: 3,
                outputs: 2,
                truthTable: null
            },
            'SR_LATCH': {
                icon: 'ğŸ”’',
                name: 'SR Latch',
                description: 'Set/Reset ë˜ì¹˜. ë©”ëª¨ë¦¬ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 2,
                truthTable: null
            },
            'D_FLIPFLOP': {
                icon: 'ğŸ“¦',
                name: 'D Flip-Flop',
                description: 'í´ëŸ­ ì‹ í˜¸ì— ë™ê¸°í™”ëœ ë©”ëª¨ë¦¬ ì†Œìì…ë‹ˆë‹¤.',
                inputs: 2,
                outputs: 2,
                truthTable: null
            }
        };

        return componentData[type] || {
            icon: 'ğŸ”Œ',
            name: type,
            description: 'ì‚¬ìš©ì ì •ì˜ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.',
            inputs: '?',
            outputs: '?',
            truthTable: null
        };
    }

    // ì„¤ëª…ì°½ ì—…ë°ì´íŠ¸
    updateComponentInfoPanel(el) {
        const type = el.getAttribute('data-type');
        this.showTooltip(type);
    }

    // ì„¤ëª…ì°½ ìˆ¨ê¸°ê¸°
    hideComponentInfoPanel() {
        const panel = document.getElementById('component-info-panel');
        if (panel) {
            panel.classList.add('hidden');
        }
    }

    deleteSelected() {
        if (this.selectedComponents.length === 0) return;

        this.selectedComponents.forEach(el => this.deleteComponent(el));
        this.selectedComponents = [];
        this.hideContextMenu();
        this.saveState();
        this.showToast('ì‚­ì œë¨', 'info');
    }

    deleteComponent(el) {
        // ì—°ê²°ëœ ì „ì„  ì œê±°
        this.wires = this.wires.filter(wire => {
            if (el.contains(wire.from) || el.contains(wire.to)) {
                wire.line.remove();
                return false;
            }
            return true;
        });
        // ë¶€í’ˆ ì œê±°
        this.components = this.components.filter(c => c !== el);
        el.remove();
        this.hideTooltip();
    }

    // ë³µì‚¬ & ë¶™ì—¬ë„£ê¸° ë¡œì§
    copySelection() {
        if (this.selectedComponents.length === 0) return;

        this.clipboard = this.selectedComponents.map(comp => {
            return {
                type: comp.getAttribute('data-type'),
                x: parseFloat(comp.style.left),
                y: parseFloat(comp.style.top)
            };
        });
        this.hideContextMenu();
    }

    pasteFromClipboard() {
        if (this.clipboard.length === 0) return;
        this.clearSelection();

        this.clipboard.forEach(data => {
            // ì‚´ì§ ê²¹ì¹˜ì§€ ì•Šê²Œ ì˜¤í”„ì…‹(+20px) ì£¼ì–´ì„œ ìƒì„±
            this.addModule(data.type, data.x + 20, data.y + 20);

            // ë°©ê¸ˆ ìƒì„±ëœ ë…€ì„ ì„ íƒ
            const newComp = this.components[this.components.length - 1];
            this.selectComponent(newComp, true);
        });
        this.hideContextMenu();
        this.updateStatusBar();
    }

    // ë³µì œ ê¸°ëŠ¥
    duplicateSelection() {
        if (this.selectedComponents.length === 0) return;

        const originals = [...this.selectedComponents];
        this.clearSelection();

        originals.forEach(comp => {
            const type = comp.getAttribute('data-type');
            const x = parseFloat(comp.style.left) + 30;
            const y = parseFloat(comp.style.top) + 30;
            this.addModule(type, x, y);

            const newComp = this.components[this.components.length - 1];
            this.selectComponent(newComp, true);
        });
        this.updateStatusBar();
    }

    // ìˆ˜í‰ ì •ë ¬
    alignHorizontal() {
        if (this.selectedComponents.length < 2) return;

        const avgY = this.selectedComponents.reduce((sum, c) =>
            sum + parseFloat(c.style.top), 0) / this.selectedComponents.length;

        this.selectedComponents.forEach(c => {
            c.style.top = avgY + 'px';
        });
        this.redrawWires();
    }

    // ìˆ˜ì§ ì •ë ¬
    alignVertical() {
        if (this.selectedComponents.length < 2) return;

        const avgX = this.selectedComponents.reduce((sum, c) =>
            sum + parseFloat(c.style.left), 0) / this.selectedComponents.length;

        this.selectedComponents.forEach(c => {
            c.style.left = avgX + 'px';
        });
        this.redrawWires();
    }

    // ì‹œë®¬ë ˆì´ì…˜ í† ê¸€
    toggleSimulation() {
        this.isRunning = !this.isRunning;
        const btn = document.getElementById('btn-run');
        if (btn) {
            if (this.isRunning) {
                btn.innerHTML = `
                <svg>
                    <use href="#icon-pause" />
                </svg>
                <span class="btn-text">ì¼ì‹œì •ì§€</span>
            `;
                btn.classList.add('active');
            } else {
                btn.innerHTML = `
                <svg>
                    <use href="#icon-play" />
                </svg>
                <span class="btn-text">ì‹¤í–‰</span>
            `;
                btn.classList.remove('active');
            }
        }
    }

    // í•œ ë‹¨ê³„ ì‹œë®¬ë ˆì´ì…˜
    stepSimulation() {
        this.updateCircuit();
        this.updateStatusBar();
    }

    // ì‹œë®¬ë ˆì´ì…˜ ì´ˆê¸°í™”
    resetSimulation() {
        this.components.forEach(c => {
            if (c.getAttribute('data-type') === 'SWITCH') {
                c.setAttribute('data-value', '0');
                const label = c.querySelector('.comp-label');
                if (label) label.innerText = 'OFF';
                c.style.background = '';
            }
        });
        this.updateCircuit();
        this.updateStatusBar();
    }

    // ë„ì›€ë§ í‘œì‹œ
    showHelp() {
        const modal = document.getElementById('help-modal');
        if (modal) modal.classList.add('show');
    }

    // ì§„ë¦¬í‘œ ëª¨ë‹¬ í‘œì‹œ
    showTruthTable() {
        const modal = document.getElementById('truth-table-modal');
        if (modal) modal.classList.add('show');
    }

    // ì§„ë¦¬í‘œ ìƒì„±
    generateTruthTable() {
        const switches = this.components.filter(c => c.getAttribute('data-type') === 'SWITCH');
        const leds = this.components.filter(c => c.getAttribute('data-type') === 'LED');

        if (switches.length === 0 || leds.length === 0) {
            document.getElementById('truth-table-content').innerHTML = `
                <p style="color: var(--accent-yellow); text-align: center; padding: 40px;">
                    âš ï¸ ìŠ¤ìœ„ì¹˜ì™€ LEDê°€ í•„ìš”í•©ë‹ˆë‹¤.<br>
                    íšŒë¡œë¥¼ ë¨¼ì € êµ¬ì„±í•´ì£¼ì„¸ìš”.
                </p>
            `;
            return;
        }

        const numInputs = switches.length;
        const numOutputs = leds.length;
        const rows = Math.pow(2, numInputs);

        // ì§„ë¦¬í‘œ í—¤ë”
        let html = '<table class="truth-table"><thead><tr>';
        switches.forEach((s, i) => {
            html += `<th>IN${i + 1}</th>`;
        });
        leds.forEach((l, i) => {
            html += `<th>OUT${i + 1}</th>`;
        });
        html += '</tr></thead><tbody>';

        // ê° ì…ë ¥ ì¡°í•©ì— ëŒ€í•´ ì‹œë®¬ë ˆì´ì…˜
        const originalStates = switches.map(s => s.getAttribute('data-value'));

        for (let row = 0; row < rows; row++) {
            html += '<tr>';

            // ì…ë ¥ ì„¤ì •
            for (let i = 0; i < numInputs; i++) {
                const bit = (row >> (numInputs - 1 - i)) & 1;
                switches[i].setAttribute('data-value', bit ? '1' : '0');
                html += `<td class="val-${bit}">${bit}</td>`;
            }

            // ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
            this.updateCircuit();

            // ì¶œë ¥ ì½ê¸°
            leds.forEach(led => {
                const val = led.getAttribute('data-value') === '1' ? 1 : 0;
                html += `<td class="val-${val}">${val}</td>`;
            });

            html += '</tr>';
        }

        html += '</tbody></table>';

        // ì›ë˜ ìƒíƒœ ë³µì›
        switches.forEach((s, i) => {
            s.setAttribute('data-value', originalStates[i]);
        });
        this.updateCircuit();

        document.getElementById('truth-table-content').innerHTML = html;
    }

    // ì§„ë¦¬í‘œ CSV ë‚´ë³´ë‚´ê¸°
    exportTruthTable() {
        const table = document.querySelector('#truth-table-content .truth-table');
        if (!table) {
            alert('ë¨¼ì € ì§„ë¦¬í‘œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.');
            return;
        }

        let csv = '';
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cells = row.querySelectorAll('th, td');
            const rowData = Array.from(cells).map(c => c.textContent);
            csv += rowData.join(',') + '\n';
        });

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'truth_table.csv';
        a.click();
        URL.revokeObjectURL(url);
    }

    // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
    updateMinimap() {
        const minimap = document.getElementById('minimap');
        const viewport = document.getElementById('minimap-viewport');
        if (!minimap || !viewport) return;

        const wrapper = this.workspace.parentElement;
        if (!wrapper) return;

        // 1. ìº”ë²„ìŠ¤ ì‹¤ì œ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
        const wVal = this.wireLayer ? (this.wireLayer.getAttribute('width') || window.getComputedStyle(this.wireLayer).width) : '6000';
        const hVal = this.wireLayer ? (this.wireLayer.getAttribute('height') || window.getComputedStyle(this.wireLayer).height) : '4000';
        const canvasWidth = parseInt(wVal) || 6000;
        const canvasHeight = parseInt(hVal) || 4000;

        // 2. ë¯¸ë‹ˆë§µ ë¹„ìœ¨ ìœ ì§€
        const mapWidth = minimap.clientWidth;
        const desiredHeight = mapWidth * (canvasHeight / canvasWidth);

        if (Math.abs(minimap.clientHeight - desiredHeight) > 1) {
            minimap.style.height = desiredHeight + 'px';
        }

        // 3. ìŠ¤ì¼€ì¼ ê³„ì‚°
        const scaleX = mapWidth / canvasWidth;
        const scaleY = desiredHeight / canvasHeight;

        // [NEW] 4. ì†Œì ê·¸ë¦¬ê¸° (Canvas í™œìš©)
        let canvas = minimap.querySelector('canvas');
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '0'; // ë·°í¬íŠ¸ ë’¤ì— ë°°ì¹˜
            canvas.style.pointerEvents = 'none';
            minimap.insertBefore(canvas, viewport);
        }

        // Canvas í•´ìƒë„ ì¡°ì •
        if (canvas.width !== mapWidth || canvas.height !== desiredHeight) {
            canvas.width = mapWidth;
            canvas.height = desiredHeight;
        }

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (this.components) {
            this.components.forEach(comp => {
                const type = comp.getAttribute('data-type');

                // ì†Œì ì¢…ë¥˜ë³„ ìƒ‰ìƒ êµ¬ë¶„
                if (['SWITCH', 'LED', 'CLOCK'].includes(type)) {
                    ctx.fillStyle = '#fbbf24'; // Amber (IO Components)
                } else if (['VCC', 'GND', 'JOINT'].includes(type)) {
                    ctx.fillStyle = '#64748b'; // Slate (Power/Joint)
                } else {
                    ctx.fillStyle = '#3b82f6'; // Blue (Gates)
                }

                // ì„ íƒëœ ì†Œì í•˜ì´ë¼ì´íŠ¸
                if (comp.classList.contains('selected')) {
                    ctx.fillStyle = '#ffffff';
                }

                const x = parseFloat(comp.style.left) || 0;
                const y = parseFloat(comp.style.top) || 0;

                // ë¯¸ë‹ˆë§µ ìƒì˜ ìœ„ì¹˜ ë³€í™˜
                const mx = x * scaleX;
                const my = y * scaleY;

                // ì†Œì í¬ê¸° ë³€í™˜ (ìµœì†Œ 3px ë³´ì¥)
                const cw = parseFloat(comp.style.width) || comp.offsetWidth || 72;
                const ch = parseFloat(comp.style.height) || comp.offsetHeight || 48;

                const mw = Math.max(3, cw * scaleX);
                const mh = Math.max(3, ch * scaleY);

                ctx.fillRect(mx, my, mw, mh);
            });
        }

        // 5. ë·°í¬íŠ¸ ì •ë³´ ê³„ì‚° (ê¸°ì¡´ ë¡œì§)
        const wrapperRect = wrapper.getBoundingClientRect();

        // ì›”ë“œ ì¢Œí‘œê³„ì—ì„œì˜ ë·°í¬íŠ¸ í¬ê¸°
        const worldVpWidth = wrapperRect.width / this.scale;
        const worldVpHeight = wrapperRect.height / this.scale;

        // ë¯¸ë‹ˆë§µ ìƒì—ì„œì˜ ë·°í¬íŠ¸ í¬ê¸°
        const vpW = worldVpWidth * scaleX;
        const vpH = worldVpHeight * scaleY;

        // ë¯¸ë‹ˆë§µ ìƒì—ì„œì˜ ë·°í¬íŠ¸ ìœ„ì¹˜
        // panXëŠ” ìŒìˆ˜ ê°’ì´ë¯€ë¡œ ì–‘ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ê³„ì‚°
        const vpL = (-this.panX / this.scale) * scaleX;
        const vpT = (-this.panY / this.scale) * scaleY;

        viewport.style.width = vpW + 'px';
        viewport.style.height = vpH + 'px';
        viewport.style.left = vpL + 'px';
        viewport.style.top = vpT + 'px';
    }

    // í”„ë¡œì íŠ¸ ë‚´ë³´ë‚´ê¸°
    exportProject() {
        const data = {
            name: this.currentProjectName,
            components: this.components.map(c => ({
                type: c.getAttribute('data-type'),
                x: parseFloat(c.style.left),
                y: parseFloat(c.style.top),
                value: c.getAttribute('data-value')
            })),
            wires: this.wires.map(w => ({
                fromId: w.from.closest('.component')?.id,
                fromPin: w.from.getAttribute('data-pinid'),
                toId: w.to.closest('.component')?.id,
                toPin: w.to.getAttribute('data-pinid')
            }))
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = (this.currentProjectName || 'circuit') + '.json';
        a.click();
        URL.revokeObjectURL(url);
    }

    // ëª¨ë“œ ì„¤ì •
    setMode(mode) {
        this.mode = mode;

        // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        ['edit', 'pan', 'wire'].forEach(m => {
            const btn = document.getElementById('btn-' + m);
            if (btn) btn.classList.toggle('active', m === mode);
        });

        // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ í´ë˜ìŠ¤ ì—…ë°ì´íŠ¸
        if (this.workspace) {
            this.workspace.classList.remove('mode-pan', 'mode-wire');
            if (mode === 'pan') this.workspace.classList.add('mode-pan');
            if (mode === 'wire') this.workspace.classList.add('mode-wire');
        }

        // ìƒíƒœë°” ì—…ë°ì´íŠ¸
        const statusMode = document.getElementById('status-mode');
        if (statusMode) {
            const modeNames = { edit: 'í¸ì§‘', pan: 'ì´ë™', wire: 'ì „ì„ ' };
            statusMode.textContent = 'ëª¨ë“œ: ' + (modeNames[mode] || mode);
        }
    }

    // ì¤Œ ì´ˆê¸°í™”
    resetZoom() {
        this.scale = 1.0;
        this.panX = 0;
        this.panY = 0;
        this.updateTransform();
    }

    // ìƒíƒœë°” ì—…ë°ì´íŠ¸
    updateStatusBar() {
        const compCount = document.getElementById('status-components');
        const wireCount = document.getElementById('status-wires');

        if (compCount) compCount.textContent = 'ë¶€í’ˆ: ' + this.components.length;
        if (wireCount) wireCount.textContent = 'ì „ì„ : ' + this.wires.length;
    }

    // ë‹¨ì¶•í‚¤ ì²˜ë¦¬
    onKeyDown(e) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        const key = e.key.toUpperCase();

        // ê¸°ë³¸ ë™ì‘
        if (key === 'DELETE' || key === 'BACKSPACE') { this.deleteSelected(); e.preventDefault(); }
        if (key === 'ESCAPE') { this.clearSelection(); this.cancelWiring(); }

        // ëª¨ë“œ ì „í™˜ ë‹¨ì¶•í‚¤
        if (key === 'V') this.setMode('edit');
        if (key === 'H') this.setMode('pan');
        if (key === 'W') this.setMode('wire');
        if (key === ' ') { this.setMode('pan'); e.preventDefault(); }
        if (key === 'R') { this.rotateSelected(); e.preventDefault(); }

        // Ctrl ì¡°í•©
        if (e.ctrlKey) {
            if (key === 'C') { this.copySelection(); e.preventDefault(); }
            if (key === 'V') { this.pasteFromClipboard(); e.preventDefault(); }
            if (key === 'D') { this.duplicateSelection(); e.preventDefault(); }
            if (key === 'S') { this.saveProject(); e.preventDefault(); }
            if (key === 'Z') { this.undo(); e.preventDefault(); }
            if (key === 'Y') { this.redo(); e.preventDefault(); }
            if (key === 'A') {
                this.components.forEach(c => this.selectComponent(c, true));
                e.preventDefault();
            }
        }

        // ì»¤ìŠ¤í…€ ë‹¨ì¶•í‚¤ í™•ì¸
        for (const [sKey, sType] of Object.entries(this.shortcuts)) {
            if (key === sKey) {
                if (sType === 'DELETE') this.deleteSelected();
                else if (sType === 'ESCAPE') this.clearSelection();
                else this.addModule(sType);
            }
        }
    }

    onKeyUp(e) {
        if (e.key === ' ') {
            this.setMode('edit');
        }
    }

    // =========================================================
    // [Section 7] Undo/Redo ì‹œìŠ¤í…œ
    // =========================================================
    saveState() {
        // í˜„ì¬ ìƒíƒœë¥¼ íˆìŠ¤í† ë¦¬ì— ì €ì¥
        const state = {
            components: this.components.map(comp => ({
                id: comp.id,
                type: comp.getAttribute('data-type'),
                x: parseFloat(comp.style.left),
                y: parseFloat(comp.style.top),
                value: comp.getAttribute('data-value')
            })),
            wires: this.wires.map(wire => ({
                fromId: wire.from.parentElement.id,
                fromPinClass: wire.from.classList[1],
                toId: wire.to.parentElement.id,
                toPinClass: wire.to.classList[1]
            }))
        };

        // í˜„ì¬ ì¸ë±ìŠ¤ ì´í›„ì˜ íˆìŠ¤í† ë¦¬ ì‚­ì œ (ìƒˆë¡œìš´ ë¶„ê¸°)
        this.history = this.history.slice(0, this.historyIndex + 1);
        this.history.push(JSON.stringify(state));
        this.historyIndex = this.history.length - 1;

        // ìµœëŒ€ íˆìŠ¤í† ë¦¬ ì œí•œ
        if (this.history.length > this.maxHistory) {
            this.history.shift();
            this.historyIndex--;
        }
    }

    undo() {
        if (this.historyIndex <= 0) {
            this.showToast('ë” ì´ìƒ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'warning');
            return;
        }

        this.historyIndex--;
        this.restoreState(JSON.parse(this.history[this.historyIndex]));
        this.showToast('ì‹¤í–‰ ì·¨ì†Œ', 'info');
    }

    redo() {
        if (this.historyIndex >= this.history.length - 1) {
            this.showToast('ë‹¤ì‹œ ì‹¤í–‰í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.', 'warning');
            return;
        }

        this.historyIndex++;
        this.restoreState(JSON.parse(this.history[this.historyIndex]));
        this.showToast('ë‹¤ì‹œ ì‹¤í–‰', 'info');
    }

    restoreState(state) {
        // ê¸°ì¡´ ìš”ì†Œ ì œê±°
        this.components.forEach(c => c.remove());
        this.wires.forEach(w => w.line.remove());
        this.components = [];
        this.wires = [];
        this.wireLayer.innerHTML = '';

        // ë¶€í’ˆ ë³µì›
        const compMap = {};
        state.components.forEach(cData => {
            this.addModule(cData.type, cData.x, cData.y);
            const newComp = this.components[this.components.length - 1];
            newComp.id = cData.id;
            if (cData.value) newComp.setAttribute('data-value', cData.value);

            // ìŠ¤ìœ„ì¹˜ ìƒíƒœ ë³µì›
            if (cData.type === 'SWITCH') {
                const label = newComp.querySelector('.comp-label');
                if (label) label.innerText = cData.value === '1' ? 'ON' : 'OFF';
            }
            compMap[cData.id] = newComp;
        });

        // ì „ì„  ë³µì›
        state.wires.forEach(wData => {
            const fromComp = compMap[wData.fromId];
            const toComp = compMap[wData.toId];
            if (fromComp && toComp) {
                const fromPin = fromComp.querySelector(`.${wData.fromPinClass}`);
                const toPin = toComp.querySelector(`.${wData.toPinClass}`);
                if (fromPin && toPin) {
                    this.createWire(fromPin, toPin);
                }
            }
        });

        this.updateCircuit();
        this.updateStatusBar();
    }

    // =========================================================
    // [Section 8] í† ìŠ¤íŠ¸ ì•Œë¦¼ ì‹œìŠ¤í…œ
    // =========================================================
    showToast(message, type = 'info') {
        // ê¸°ì¡´ í† ìŠ¤íŠ¸ ì œê±°
        const existingToast = document.querySelector('.toast-notification');
        if (existingToast) existingToast.remove();

        const toast = document.createElement('div');
        toast.className = `toast-notification toast-${type}`;
        toast.innerHTML = `
            <span class="toast-icon">${type === 'success' ? 'âœ“' : type === 'warning' ? 'âš ' : type === 'error' ? 'âœ•' : 'â„¹'}</span>
            <span class="toast-message">${message}</span>
        `;

        document.body.appendChild(toast);

        // ì• ë‹ˆë©”ì´ì…˜ í›„ í‘œì‹œ
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });

        // 3ì´ˆ í›„ ìë™ ì œê±°
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    // ë‹¨ì¶•í‚¤ ì„¤ì • ëª¨ë‹¬
    openShortcutModal() {
        const list = document.getElementById('shortcut-list');
        list.innerHTML = '';
        for (const [key, type] of Object.entries(this.shortcuts)) {
            const row = document.createElement('div');
            row.className = 'key-row';
            row.innerHTML = `<span>${type}</span><input type="text" class="key-input" value="${key}" data-type="${type}" maxlength="1">`;
            list.appendChild(row);
        }
        document.getElementById('shortcut-modal').style.display = 'flex';
    }

    closeShortcutModal() {
        const inputs = document.querySelectorAll('.key-input');
        const newShortcuts = {};
        inputs.forEach(input => {
            if (input.value.trim()) {
                newShortcuts[input.value.toUpperCase()] = input.getAttribute('data-type');
            }
        });
        this.shortcuts = newShortcuts;
        document.getElementById('shortcut-modal').style.display = 'none';
        document.getElementById('shortcut-modal').style.display = 'none';
        alert(this.dict.shortcutSaved);
    }

    setLanguage(lang) {
        if (!TRANSLATIONS[lang]) return;
        this.currentLang = lang;
        this.dict = TRANSLATIONS[lang];

        // UI í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        this.updateUIText();
    }

    updateUIText() {
        const t = this.dict;
        if (!t) return;

        // 1. Static Text Updates
        const header = document.querySelector('#toolbox h2');
        if (header) header.innerText = t.component;

        const btnSave = document.getElementById('btn-save');
        if (btnSave) btnSave.innerHTML = t.save;

        const btnExit = document.getElementById('btn-exit');
        if (btnExit) btnExit.innerHTML = t.exit;

        const btnEdit = document.getElementById('btn-edit');
        if (btnEdit) btnEdit.innerHTML = t.edit;

        const btnPan = document.getElementById('btn-pan');
        if (btnPan) btnPan.innerHTML = t.pan;

        // Zoom buttons
        const zoomBtns = document.querySelectorAll('.zoom-controls button');
        if (zoomBtns[0]) zoomBtns[0].innerText = t.zoomOut;
        if (zoomBtns[1]) zoomBtns[1].innerText = t.zoomIn;

        // Categories
        const cats = document.querySelectorAll('.category');
        if (cats.length >= 4) {
            if (cats[0]) cats[0].innerText = t.inputOutput;
            if (cats[1]) cats[1].innerText = t.logicGates;
            // cats[2] is Expert Menu Header? Or "Settings"?
            // Previous view showed cats[2] assigned to "Hierarchy" or "Settings"?
            // Let's rely on index.
            // Toolbox structure: Input/Output(0), Logic Gates(1), Expert(2 - hidden or header?), Settings(Last).
            // Let's safe guard.
            if (cats[cats.length - 1]) cats[cats.length - 1].innerText = t.settings;
        }

        // Mode Button
        const modeBtn = document.getElementById('btn-mode');
        if (modeBtn) {
            if (this.userMode === 'expert') {
                modeBtn.innerText = t.modeExpert;
            } else {
                modeBtn.innerText = t.modeEasy;
            }
        }

        // 2. Dynamic Button Text (Gates)
        // We use a mapping from onclick attribute to translation key
        const btnMap = {
            "'SWITCH'": t.gateSwitch,
            "'LED'": t.gateLed,
            "'CLOCK'": t.gateClock,
            "'AND'": t.gateAnd,
            "'OR'": t.gateOr,
            "'NOT'": t.gateNot,
            "'XOR'": t.gateXor,
            "'NAND'": t.gateNand,
            "'NOR'": t.gateNor,
            "'XNOR'": t.gateXnor,
            "'TRANSISTOR'": t.gateTr,
            "'PMOS'": t.gatePmos,
            "'VCC'": t.gateVcc,
            "'GND'": t.gateGnd
        };

        const buttons = document.querySelectorAll('.tool-btn');
        buttons.forEach(btn => {
            const onClick = btn.getAttribute('onclick');
            if (!onClick) return;
            for (const [key, text] of Object.entries(btnMap)) {
                if (onClick.includes(key)) {
                    // Try to preserve icon (first word or emoji)
                    const parts = btn.innerText.split(' ');
                    const icon = parts[0];
                    let isEmoji = false;
                    try {
                        isEmoji = icon && /\p{Emoji}/u.test(icon);
                    } catch (e) {
                        // Fallback for older browsers
                        isEmoji = icon && icon.charCodeAt(0) > 255;
                    }

                    if (isEmoji) {
                        btn.innerText = icon + " " + text;
                    } else {
                        btn.innerText = text;
                    }
                }
            }
        });
    }

    // [Section 4-1] Expert Mode & Property Modal
    // =========================================================
    updateModeButton() {
        const btn = document.getElementById('btn-mode');
        if (!btn) return;

        if (this.userMode === 'expert') {
            btn.innerHTML = 'ğŸ”§ Expert';
            btn.classList.add('active');
        } else {
            btn.innerHTML = 'ğŸ“ Easy';
            btn.classList.remove('active');
        }
    }

    openPropertyModal(comp) {
        if (!comp) return;
        this.currentEditComp = comp;

        // ëª¨ë‹¬ DOM ìƒì„±/ì¬í™œìš© (ê¸°ì¡´ shortcut-modal ë§ê³  ë³„ë„ ìƒì„±)
        let modal = document.getElementById('property-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'property-modal';
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-window">
                    <div class="modal-header">ğŸ”§ ë¶€í’ˆ ì†ì„± (Properties)</div>
                    <div class="key-row">
                        <span>Type</span> <span id="prop-type">AND</span>
                    </div>
                    <div class="key-row">
                        <span>Delay (ms)</span> <input type="number" id="prop-delay" class="key-input" style="width: 80px;">
                    </div>
                    <div class="key-row">
                        <span>Transistors</span> <input type="number" id="prop-transistors" class="key-input" style="width: 80px;">
                    </div>
                    <button class="modal-btn" onclick="sim.saveProperties()">ì €ì¥ (Save)</button>
                    <button class="modal-btn" style="background:#95a5a6; margin-top:5px;" onclick="document.getElementById('property-modal').style.display='none'">ë‹«ê¸° (Close)</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // ê°’ ì±„ìš°ê¸°
        const type = comp.getAttribute('data-type');
        document.getElementById('prop-type').innerText = type;
        document.getElementById('prop-delay').value = comp.getAttribute('data-delay') || '10';
        document.getElementById('prop-transistors').value = comp.getAttribute('data-transistors') || '0';

        modal.style.display = 'flex';
    }

    saveProperties() {
        if (!this.currentEditComp) return;

        const delay = document.getElementById('prop-delay').value;
        const transistors = document.getElementById('prop-transistors').value;

        this.currentEditComp.setAttribute('data-delay', delay);
        this.currentEditComp.setAttribute('data-transistors', transistors);

        document.getElementById('property-modal').style.display = 'none';
        this.currentEditComp = null;
    }

    // =========================================================
    // [Section 5] ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„ (Logic Engine)
    // =========================================================
    toggleSwitch(e, el) {
        if (this.mode !== 'edit') return;

        // [New Fix] ì„ íƒë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ í´ë¦­ ì‹œ -> ì„ íƒë§Œ í•˜ê³  í† ê¸€ ì•ˆ í•¨
        // (ì‚¬ìš©ì ìš”ì²­: "ì „ì› í´ë¦­í•˜ë©´ ë°•ìŠ¤ ìƒê¸°ë©´ì„œ ê°’ ë°”ë€ŒëŠ” ë¬¸ì œ" í•´ê²°)
        if (this.componentWasSelected === false) {
            return;
        }

        const current = el.getAttribute('data-value');
        const next = current === '1' ? '0' : '1';
        el.setAttribute('data-value', next);

        const label = el.querySelector('.comp-label');
        if (label) label.innerText = next === '1' ? 'ON' : 'OFF';

        // el.style.background = next === '1' ? '#2ecc71' : '#27ae60'; // ì‚­ì œ (ë„¤ëª¨ ë°•ìŠ¤ ë°©ì§€)

        // ì‹¬ë³¼ ìƒ‰ìƒ ë³€ê²½ (SVG stroke="currentColor")
        if (next === '1') {
            el.style.color = '#4ade80'; // Bright Green (ON)
        } else {
            el.style.color = ''; // Default (OFF)
        }
        this.updateCircuit();
    }

    clockTick() {
        const clocks = document.querySelectorAll('.component[data-type="CLOCK"]');
        if (clocks.length === 0) return;

        clocks.forEach(clk => {
            const current = clk.getAttribute('data-value');
            const next = current === '1' ? '0' : '1';
            clk.setAttribute('data-value', next);

            const label = clk.querySelector('.comp-label');
            if (label) label.innerText = next === '1' ? 'HIGH' : 'LOW';

            clk.style.background = next === '1' ? '#9b59b6' : '#8e44ad';
            clk.style.boxShadow = next === '1' ? '0 0 10px #9b59b6' : '3px 3px 10px rgba(0,0,0,0.2)';
        });
        this.updateCircuit();
    }

    restoreInternals(parentComp, data) {
        // Clear default internals
        parentComp.internals = { components: [], wires: [] };
        const idMap = {};

        // Restore Components
        data.components.forEach(part => {
            const el = document.createElement('div');
            el.classList.add('component');
            el.id = part.id;
            el.setAttribute('data-type', part.type);
            el.setAttribute('data-value', part.value || '0');
            el.style.left = part.x + 'px';
            el.style.top = part.y + 'px';

            const label = document.createElement('div');
            label.classList.add('comp-label');
            label.innerText = part.label || part.type;
            el.appendChild(label);

            // Reuse pin logic 
            // (Copy from buildInternals or simplify by calling addModule logic? 
            //  But logic relies on standard types. 'part.type' should be standard.)
            const type = part.type;
            if (type === 'TRANSISTOR' || type === 'PMOS') {
                this.addPin(el, 'base', 'input base');
                this.addPin(el, 'col', 'input col');
                this.addPin(el, 'emit', 'output emit');
            } else if (type === 'VCC' || type === 'GND' || type === 'PORT_IN') {
                this.addPin(el, 'out', 'output center');
            } else if (type === 'PORT_OUT') {
                this.addPin(el, 'in', 'input center');
            }

            idMap[part.id] = el;
            parentComp.internals.components.push(el);
        });

        // Restore Wires
        data.wires.forEach(wData => {
            const fromComp = idMap[wData.fromCompId];
            const toComp = idMap[wData.toCompId];

            if (fromComp && toComp) {
                const fromPin = fromComp.querySelector(`.${wData.fromPinClass}`);
                const toPin = toComp.querySelector(`.${wData.toPinClass}`);

                if (fromPin && toPin) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    parentComp.internals.wires.push({ from: fromPin, to: toPin, line: line });
                }
            }
        });
    }

    // [Optimization] ë‹¨ìˆœí™”ëœ ì „íŒŒ ë¡œì§
    // DOM ì ‘ê·¼ì„ ìµœì†Œí™”í•˜ê³ , ë³€ê²½ì‚¬í•­ë§Œ ì—…ë°ì´íŠ¸
    // [Updated] ì „íŒŒ ë¡œì§ ë°˜ë³µ ì‹¤í–‰ (ì‹ í˜¸ ì•ˆì •í™”)
    updateCircuit() {
        let changed = false;
        let limit = 50; // ë¬´í•œ ë£¨í”„ ë°©ì§€ (ìµœëŒ€ ì „íŒŒ ê¹Šì´)

        while (limit > 0) {
            let stepChanged = false;

            // 1. ì „ì„  ì‹ í˜¸ ì „íŒŒ (Component Output -> Wire)
            if (this.propagate()) stepChanged = true;

            // 2. ë¶€í’ˆ ë¡œì§ í‰ê°€ (Wire Input -> Component Output)
            if (this.propagateList(this.components)) stepChanged = true;

            if (!stepChanged) break; // ë” ì´ìƒ ë³€í™” ì—†ìœ¼ë©´ ì¤‘ë‹¨
            changed = true;
            limit--;
        }

        // LED ë° ì‹œê°ì  ìƒíƒœ ì—…ë°ì´íŠ¸
        this.updateLEDs();

        // ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ ì—…ë°ì´íŠ¸ (ë³€í™”ê°€ ìˆì—ˆì„ ë•Œë§Œ? ì•„ë‹ˆë©´ í•­ìƒ? -> ë³´í†µ ì£¼ê¸°ì ìœ¼ë¡œ í•˜ì§€ë§Œ ì—¬ê¸°ì„œ í˜¸ì¶œ)
        if (this.oscilloscope) this.oscilloscope.update();

        return changed;
    }

    // LED ì‹œê°ì  ìƒíƒœ ì—…ë°ì´íŠ¸
    updateLEDs() {
        this.components.forEach(comp => {
            const type = comp.getAttribute('data-type');
            if (type === 'LED') {
                const val = comp.getAttribute('data-value') === '1';
                if (val) {
                    comp.classList.add('led-on');
                } else {
                    comp.classList.remove('led-on');
                }
            }
        });
    }

    // Evaluate Composite Component (Sub-circuit)
    evaluateComposite(comp) {
        if (!comp.internals) return false;

        let changed = false;

        // 1. Map External Inputs -> Internal PORT_IN
        // Identify external Input pins
        const in1 = comp.querySelector('.in-1')?.getAttribute('data-signal') === '1';
        const in2 = comp.querySelector('.in-2')?.getAttribute('data-signal') === '1';

        // Identify Internal Ports (Assuming default ID scheme from default schematic, 
        // OR filtering by type PORT_IN. Filtering is safer)
        const portIns = comp.internals.components.filter(c => c.getAttribute('data-type') === 'PORT_IN');

        // Heuristic mapping: Sort ports by ID or 'left' position? 
        // Default schematics used IDs 'in_1', 'in_2'.
        // Let's use ID matching if possible.
        portIns.forEach(port => {
            // Find which external pin maps to this port
            // Convention: ID ends with 'in_1' maps to external 'in-1'
            let val = false;
            if (port.id.endsWith('in_1')) val = in1;
            else if (port.id.endsWith('in_2')) val = in2;
            else if (port.id.endsWith('in')) val = in1; // Single input case

            if (port.getAttribute('data-value') !== (val ? '1' : '0')) {
                port.setAttribute('data-value', val ? '1' : '0');
                changed = true;
            }
        });

        // 2. Propagate Internals
        // Trigger propagation loop for internals
        // Optimization: Run a mini-loop
        for (let i = 0; i < 5; i++) {
            // We need a version of propagate that takes a specialized list
            if (this.propagateList(comp.internals.components, comp.internals.wires)) {
                changed = true;
            } else {
                break;
            }
        }

        // 3. Map Internal PORT_OUT -> External Output
        const portOuts = comp.internals.components.filter(c => c.getAttribute('data-type') === 'PORT_OUT');
        if (portOuts.length > 0) {
            // Assume single output 'out' for gates
            const res = portOuts[0].querySelector('.in')?.getAttribute('data-signal') === '1';

            const currentVal = comp.getAttribute('data-value') === '1';
            if (res !== currentVal) {
                comp.setAttribute('data-value', res ? '1' : '0');
                changed = true;
            }
        }

        return changed;
    }

    // Generic propagate for any component list (Main or Internal)
    propagateList(components, wires) {
        let changed = false;

        // Null safety checks
        if (!wires || !Array.isArray(wires)) wires = [];
        if (!components || !Array.isArray(components)) components = [];

        wires.forEach(wire => {
            const fromVal = wire.from.parentElement.getAttribute('data-value') === '1';
            const currentSignal = wire.to.getAttribute('data-signal') === '1';

            if (fromVal !== currentSignal) {
                wire.to.setAttribute('data-signal', fromVal ? '1' : '0');
                if (this.currentScopeComp && components === this.currentScopeComp.internals.components) {
                    // Check if visible to update UI?
                    // Actually, if we are viewing internals, 'components' IS 'this.components'
                    // so the standard UI update handles it.
                    // But if we are simulating background internals, NO UI update needed.
                }
                // If background simulation (elements not in DOM/View), wire.line is not visible.
                // So simple attribute setting is enough.
                changed = true;
            }
        });

        components.forEach(comp => {
            const type = comp.getAttribute('data-type');
            if (['SWITCH', 'CLOCK', 'VCC', 'GND', 'PORT_IN'].includes(type)) return;

            // Gather inputs
            const in1 = comp.querySelector('.in-1')?.getAttribute('data-signal') === '1';
            const in2 = comp.querySelector('.in-2')?.getAttribute('data-signal') === '1';
            let res = false;

            switch (type) {
                case 'AND': res = in1 && in2; break;
                case 'OR': res = in1 || in2; break;
                case 'NOT': res = !in1; break;
                case 'XOR': res = (in1 !== in2); break;
                case 'NAND': res = !(in1 && in2); break;
                case 'NOR': res = !(in1 || in2); break;
                case 'XNOR': res = (in1 === in2); break;
                case 'JOINT': res = comp.querySelector('.pin')?.getAttribute('data-signal') === '1'; break;
                case 'LED': res = in1; break;
                case 'PORT_OUT':
                    // Port out just reflects its input pin
                    res = comp.querySelector('.in')?.getAttribute('data-signal') === '1';
                    // Use 'data-value' to store it so external mapper can read it
                    break;
                case 'TRANSISTOR':
                    const valBase = comp.querySelector('.base')?.getAttribute('data-signal') === '1';
                    const valCol = comp.querySelector('.col')?.getAttribute('data-signal') === '1';
                    res = valBase && valCol;
                    break;
                case 'PMOS':
                    // PMOS: Base Low -> Conducts. 
                    // Switch Model: If Base=0, Emit = Col. Else Emit = 0 (Open)
                    // Note: This model is imperfect for "Pull Up" scenarios where logic 1 comes from VCC.
                    // But strictly speaking: 
                    // If Base=0 (Low), Switch Closed. Emit takes Col's value.
                    // If Base=1 (High), Switch Open. Emit takes... 0? Floating?
                    // In valid CMOS, there's always a path to VCC or GND.
                    // In our simplified sim, assume 0 (Floating = 0).
                    const pBase = comp.querySelector('.base')?.getAttribute('data-signal') === '1';
                    const pCol = comp.querySelector('.col')?.getAttribute('data-signal') === '1'; // Typically VCC(1)
                    if (!pBase) res = pCol; // Conducts if Base is Low
                    else res = false; // Open
                    break;
                case 'PACKAGE':
                    // íŒ¨í‚¤ì§€ëŠ” ë‚´ë¶€ íšŒë¡œê°€ ì•„ë‹Œ ë¸”ë™ë°•ìŠ¤ë¡œ ì‘ë™
                    // ì…ë ¥ í•€ë“¤ì˜ ì¡°í•©ì„ ê¸°ë°˜ìœ¼ë¡œ ì¶œë ¥ ê²°ì •
                    const pkgIdx = parseInt(comp.getAttribute('data-package-id'));
                    const pkgDef = this.userPackages?.[pkgIdx];
                    if (pkgDef && pkgDef.circuit) {
                        // ê°„ë‹¨í•œ íŒ¨ìŠ¤ìŠ¤ë£¨: ì²«ë²ˆì§¸ ì…ë ¥ì„ ì²«ë²ˆì§¸ ì¶œë ¥ìœ¼ë¡œ ì „ë‹¬
                        const in0 = comp.querySelector('.in0')?.getAttribute('data-signal') === '1';
                        res = in0;
                    }
                    break;
                // BUILTIN_PACKAGE ì¼€ì´ìŠ¤ ì œê±°ë¨ - ë…¼ë¦¬ ê²Œì´íŠ¸ëŠ” addModule()ë¡œ ì¶”ê°€ë¨
            }

            // Check composite
            if (comp.internals) {
                // Warning: Recursive but handled by loop limits
                // If we are simulating a background component, simple logic is skipped by above switch
                // UNLESS generic Gates (AND/OR) also have logic above?
                // The 'switch' above handles standard logic.
                // IF we want to enforce "Transistor Circuit determines Logic", we should skip standard logic
                // when internals exist.
            }

            const currentVal = comp.getAttribute('data-value') === '1';
            if (res !== currentVal) {
                comp.setAttribute('data-value', res ? '1' : '0');
                changed = true;
            }
        });

        return changed;
    }

    // [Fixed] ì‹ í˜¸ ì „íŒŒ ë° ì‹œê°ì  ë™ê¸°í™” ë¡œì§ ê°œì„ 
    propagate() {
        let changed = false;
        if (!this.wires) return false;

        this.wires.forEach(wire => {
            if (!wire.from || !wire.to || !wire.line) return;

            // DOM ì—°ê²° ìƒíƒœ í™•ì¸ (ì‚­ì œëœ ë…¸ë“œ ì°¸ì¡° ë°©ì§€)
            // if (!wire.from.isConnected || !wire.to.isConnected) return; // (êµ¬í˜• ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ìœ„í•´ ìƒëµ ê°€ëŠ¥í•˜ë‚˜ ì•ˆì „ì¥ì¹˜ë¡œ ì¢‹ìŒ)

            const fromComp = wire.from.closest('.component');
            if (!fromComp) return;

            // 1. ì†ŒìŠ¤ ê°’ ì½ê¸°
            const fromVal = fromComp.getAttribute('data-value') === '1';

            // 2. íƒ€ê²Ÿ ê°’ í™•ì¸
            const currentSignal = wire.to.getAttribute('data-signal') === '1';

            // 3. ì‹œê°ì  ìƒíƒœ í™•ì¸
            const isVisuallyOn = wire.line.classList.contains('on');

            // [Logic Update] ì‹ í˜¸ê°€ ë‹¤ë¥´ë©´ ì—…ë°ì´íŠ¸
            if (fromVal !== currentSignal) {
                wire.to.setAttribute('data-signal', fromVal ? '1' : '0');
                changed = true;
            }

            // [Visual Update] ì‹œê° ìƒíƒœê°€ ë‹¤ë¥´ë©´ ê°•ì œ ë™ê¸°í™” (ë²„ê·¸ ìˆ˜ì • í•µì‹¬)
            if (fromVal !== isVisuallyOn) {
                if (fromVal) wire.line.classList.add('on');
                else wire.line.classList.remove('on');
            }
        });

        return changed; // ë…¼ë¦¬ì  ë³€ê²½ë§Œ ë³´ê³  (ë£¨í”„ ì œì–´ìš©)
    }



    // =========================================================
    // [Section 6] ê¸°íƒ€ UI (ëª¨ë“œ, ì¤Œ, íˆ´íŒ)
    // =========================================================
    setMode(mode) {
        this.mode = mode;

        if (this.workspace) {
            this.workspace.classList.remove('mode-pan', 'mode-wire');
            if (mode === 'pan') this.workspace.classList.add('mode-pan');
            if (mode === 'wire') this.workspace.classList.add('mode-wire');
        }

        const btnSelect = document.getElementById('btn-select');
        const btnPan = document.getElementById('btn-pan');
        const btnWire = document.getElementById('btn-wire');

        if (btnSelect) btnSelect.classList.toggle('active', mode === 'edit');
        if (btnPan) btnPan.classList.toggle('active', mode === 'pan');
        if (btnWire) btnWire.classList.toggle('active', mode === 'wire');
    }

    toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
            sidebar.classList.toggle('collapsed');

            // bodyì—ë„ í´ë˜ìŠ¤ ì¶”ê°€í•˜ì—¬ ì„¤ëª…ì°½ ìœ„ì¹˜ ì¡°ì •
            document.body.classList.toggle('sidebar-collapsed', sidebar.classList.contains('collapsed'));

            // ì‚¬ì´ë“œë°” ë²„íŠ¼ ì•„ì´ì½˜ íšŒì „ íš¨ê³¼ ë“±ì€ CSSë¡œ ì²˜ë¦¬ë¨
            // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ íŠ¸ë¦¬ê±° (ë¯¸ë‹ˆë§µ ë“± ê°±ì‹  ìœ„í•´)
            setTimeout(() => this.resizeCanvas(), 300);
        }
    }

    toggleSection(id) {
        const section = document.getElementById(id);
        if (section) {
            section.classList.toggle('collapsed');
        }
    }

    zoom(amount) {
        this.scale += amount;
        if (this.scale < 0.5) this.scale = 0.5;
        if (this.scale > 2.0) this.scale = 2.0;
        this.updateTransform();
    }

    updateTransform() {
        if (!this.workspace) return;

        // [Canvas Boundary Constraint]
        // ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ í™”ë©´ì´ ì´ë™í•˜ì§€ ëª»í•˜ë„ë¡ ì œí•œ
        const wrapper = this.workspace.parentElement; // workspace-wrapper
        if (wrapper) {
            const viewWidth = wrapper.clientWidth;
            const viewHeight = wrapper.clientHeight;

            // ìº”ë²„ìŠ¤ ì‹¤ì œ í¬ê¸° (ìŠ¤ì¼€ì¼ ì ìš©) - ê¸°ë³¸ê°’ 6000x4000
            const baseWidth = parseInt(this.wireLayer?.getAttribute('width')) || 6000;
            const baseHeight = parseInt(this.wireLayer?.getAttribute('height')) || 4000;

            const scaledWidth = baseWidth * this.scale;
            const scaledHeight = baseHeight * this.scale;

            // Xì¶• ì œí•œ
            if (scaledWidth > viewWidth) {
                // panXëŠ” 0(ì™¼ìª½ ë) ~ viewWidth - scaledWidth(ì˜¤ë¥¸ìª½ ë) ì‚¬ì´ì—¬ì•¼ í•¨
                // (panXê°€ ìŒìˆ˜ì´ë¯€ë¡œ, 0ì´ ìµœëŒ€ê°’ì´ê³  viewWidth - scaledWidthê°€ ìµœì†Œê°’)
                const minX = viewWidth - scaledWidth;
                const maxX = 0;
                this.panX = Math.min(maxX, Math.max(this.panX, minX));
            } else {
                // ìº”ë²„ìŠ¤ê°€ í™”ë©´ë³´ë‹¤ ì‘ìœ¼ë©´ 0ìœ¼ë¡œ ê³ ì • (ì™¼ìª½ ìƒë‹¨ ê¸°ì¤€)
                this.panX = 0;
            }

            // Yì¶• ì œí•œ
            if (scaledHeight > viewHeight) {
                const minY = viewHeight - scaledHeight;
                const maxY = 0;
                this.panY = Math.min(maxY, Math.max(this.panY, minY));
            } else {
                this.panY = 0;
            }
        }

        this.workspace.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
        const zoomEl = document.getElementById('zoom-level');
        if (zoomEl) zoomEl.innerText = Math.round(this.scale * 100) + '%';
        this.redrawWires();
        this.updateMinimap();
    }

    showTooltip(type) {
        // component-info-panel ì‚¬ìš© (ì¢Œì¸¡ ìƒë‹¨ ê³ ì •)
        const info = this.getComponentInfo(type);
        if (!info) return;

        const panel = document.getElementById('component-info-panel');
        if (!panel) return;

        // ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„°
        const animationData = {
            'AND': `<svg viewBox="0 0 280 80"><path d="M40 20 L80 20 A 20 20 0 0 1 80 60 L40 60 Z" fill="none" stroke="#3b82f6" stroke-width="2"/><line x1="10" y1="30" x2="40" y2="30" stroke="#22c55e" stroke-width="3" class="anim-wire"/><line x1="10" y1="50" x2="40" y2="50" stroke="#22c55e" stroke-width="3" class="anim-wire"/><line x1="100" y1="40" x2="130" y2="40" stroke="#22c55e" stroke-width="3" class="anim-wire"/><text x="150" y="35" fill="#94a3b8" font-size="11">1 AND 1 = 1</text><text x="150" y="52" fill="#94a3b8" font-size="11">1 AND 0 = 0</text></svg>`,
            'OR': `<svg viewBox="0 0 280 80"><path d="M35 20 Q 50 40 35 60 Q 70 60 90 40 Q 70 20 35 20 Z" fill="none" stroke="#06b6d4" stroke-width="2"/><line x1="10" y1="30" x2="42" y2="30" stroke="#22c55e" stroke-width="3" class="anim-wire"/><line x1="10" y1="50" x2="42" y2="50" stroke="#64748b" stroke-width="3"/><line x1="90" y1="40" x2="120" y2="40" stroke="#22c55e" stroke-width="3" class="anim-wire"/><text x="140" y="35" fill="#94a3b8" font-size="11">1 OR 0 = 1</text><text x="140" y="52" fill="#94a3b8" font-size="11">0 OR 0 = 0</text></svg>`,
            'NOT': `<svg viewBox="0 0 280 80"><path d="M40 20 L80 40 L40 60 Z" fill="none" stroke="#f59e0b" stroke-width="2"/><circle cx="88" cy="40" r="6" fill="none" stroke="#f59e0b" stroke-width="2"/><line x1="10" y1="40" x2="40" y2="40" stroke="#22c55e" stroke-width="3" class="anim-wire"/><line x1="94" y1="40" x2="120" y2="40" stroke="#64748b" stroke-width="3"/><text x="140" y="35" fill="#94a3b8" font-size="11">NOT 1 = 0</text><text x="140" y="52" fill="#94a3b8" font-size="11">NOT 0 = 1</text></svg>`,
            'XOR': `<svg viewBox="0 0 280 80"><path d="M45 20 Q 60 40 45 60 Q 75 60 95 40 Q 75 20 45 20 Z" fill="none" stroke="#8b5cf6" stroke-width="2"/><path d="M35 20 Q 50 40 35 60" fill="none" stroke="#8b5cf6" stroke-width="2"/><text x="130" y="35" fill="#94a3b8" font-size="11">1 XOR 0 = 1</text><text x="130" y="52" fill="#94a3b8" font-size="11">1 XOR 1 = 0</text></svg>`,
            'NAND': `<svg viewBox="0 0 280 80"><path d="M40 20 L75 20 A 20 20 0 0 1 75 60 L40 60 Z" fill="none" stroke="#ec4899" stroke-width="2"/><circle cx="100" cy="40" r="6" fill="none" stroke="#ec4899" stroke-width="2"/><text x="130" y="35" fill="#94a3b8" font-size="11">1 NAND 1 = 0</text><text x="130" y="52" fill="#94a3b8" font-size="11">1 NAND 0 = 1</text></svg>`,
            'NOR': `<svg viewBox="0 0 280 80"><path d="M35 20 Q 50 40 35 60 Q 65 60 85 40 Q 65 20 35 20 Z" fill="none" stroke="#ef4444" stroke-width="2"/><circle cx="93" cy="40" r="6" fill="none" stroke="#ef4444" stroke-width="2"/><text x="120" y="35" fill="#94a3b8" font-size="11">0 NOR 0 = 1</text><text x="120" y="52" fill="#94a3b8" font-size="11">1 NOR 0 = 0</text></svg>`,
            'XNOR': `<svg viewBox="0 0 280 80"><path d="M45 20 Q 60 40 45 60 Q 70 60 85 40 Q 70 20 45 20 Z" fill="none" stroke="#a855f7" stroke-width="2"/><path d="M35 20 Q 50 40 35 60" fill="none" stroke="#a855f7" stroke-width="2"/><circle cx="93" cy="40" r="6" fill="none" stroke="#a855f7" stroke-width="2"/><text x="120" y="35" fill="#94a3b8" font-size="11">1 XNOR 1 = 1</text><text x="120" y="52" fill="#94a3b8" font-size="11">1 XNOR 0 = 0</text></svg>`,
            'SWITCH': `<svg viewBox="0 0 280 80"><circle cx="50" cy="40" r="18" fill="none" stroke="#22c55e" stroke-width="2"/><circle cx="50" cy="40" r="10" fill="#22c55e"/><line x1="68" y1="40" x2="100" y2="40" stroke="#22c55e" stroke-width="3"/><text x="120" y="44" fill="#94a3b8" font-size="12">ON = 1, OFF = 0</text></svg>`,
            'LED': `<svg viewBox="0 0 280 80"><line x1="10" y1="40" x2="35" y2="40" stroke="#22c55e" stroke-width="3" class="anim-wire"/><circle cx="55" cy="40" r="18" fill="rgba(234, 179, 8, 0.3)" stroke="#eab308" stroke-width="2"/><circle cx="55" cy="40" r="10" fill="#eab308" class="led-glow"/><text x="90" y="44" fill="#94a3b8" font-size="12">INPUT 1 â†’ ğŸ’¡</text></svg>`,
            'CLOCK': `<svg viewBox="0 0 280 80"><rect x="25" y="25" width="50" height="30" fill="none" stroke="#3b82f6" stroke-width="2" rx="4"/><path d="M10 40 L25 40 M75 40 L100 40" stroke="#3b82f6" stroke-width="2"/><path d="M35 35 L35 45 L50 45 L50 35 L65 35" stroke="#22c55e" stroke-width="2" fill="none" class="anim-wire"/><text x="110" y="44" fill="#94a3b8" font-size="11">ì£¼ê¸°ì  í„ìŠ¤</text></svg>`
        };

        // ì‚¬ìš©ë²• ë°ì´í„°
        const usageData = {
            'AND': 'ë‘ ê°œ ì´ìƒì˜ ì¡°ê±´ì´ ëª¨ë‘ ì°¸ì´ì–´ì•¼ í•˜ëŠ” ê²½ìš°ì— ì‚¬ìš©í•©ë‹ˆë‹¤.',
            'OR': 'ì—¬ëŸ¬ ì¡°ê±´ ì¤‘ í•˜ë‚˜ë§Œ ë§Œì¡±í•´ë„ ë˜ëŠ” ê²½ìš°ì— ì‚¬ìš©í•©ë‹ˆë‹¤.',
            'NOT': 'ì‹ í˜¸ë¥¼ ë°˜ì „ì‹œí‚¬ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì¸ë²„í„°ë¼ê³ ë„ í•©ë‹ˆë‹¤.',
            'XOR': 'ë‘ ì‹ í˜¸ê°€ ë‹¤ë¥¸ì§€ ë¹„êµí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. íŒ¨ë¦¬í‹° ì²´í¬ì— í™œìš©.',
            'NAND': 'ë²”ìš© ê²Œì´íŠ¸ì…ë‹ˆë‹¤. ëª¨ë“  ë…¼ë¦¬ë¥¼ NANDë§Œìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥í•©ë‹ˆë‹¤.',
            'NOR': 'ë²”ìš© ê²Œì´íŠ¸ì…ë‹ˆë‹¤. ë˜ì¹˜(Latch) íšŒë¡œ êµ¬ì„±ì— ë§ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.',
            'XNOR': 'ë‘ ì‹ í˜¸ê°€ ê°™ì€ì§€ ë¹„êµí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ë™ë“± ë¹„êµê¸°.',
            'SWITCH': 'í´ë¦­í•´ì„œ ì¼œê³  ë„ì„¸ìš”. ì´ˆë¡ìƒ‰ì´ë©´ ON(1), íšŒìƒ‰ì´ë©´ OFF(0).',
            'LED': 'ë‹¤ë¥¸ ê²Œì´íŠ¸ì˜ ì¶œë ¥ì„ ì—°ê²°í•˜ì—¬ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”.',
            'CLOCK': 'ìˆœì°¨ íšŒë¡œ, ì¹´ìš´í„°, íƒ€ì´ë° íšŒë¡œì— í•„ìˆ˜ì ì¸ ì†Œìì…ë‹ˆë‹¤.',
            'TRANSISTOR': 'ê²Œì´íŠ¸ì— ì œì–´ ì‹ í˜¸ë¥¼ ì—°ê²°í•˜ì—¬ ì „ë¥˜ íë¦„ì„ ì œì–´í•©ë‹ˆë‹¤.',
            'PMOS': 'NMOSì™€ í•¨ê»˜ CMOS íšŒë¡œë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.',
            'VCC': 'í’€ì—… ì €í•­ì´ë‚˜ ìƒìˆ˜ 1 ì…ë ¥ì´ í•„ìš”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.',
            'GND': 'í’€ë‹¤ìš´ ì €í•­ì´ë‚˜ ìƒìˆ˜ 0 ì…ë ¥ì´ í•„ìš”í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.',
            'JOINT': 'ì „ì„  ë¶„ê¸°ì ì„ ë§Œë“¤ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‹ í˜¸ë¥¼ ì—¬ëŸ¬ ê³³ì— ì „ë‹¬.',
            'PACKAGE': 'ë”ë¸”í´ë¦­í•˜ì—¬ ë‚´ë¶€ íšŒë¡œë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
        };

        // ì•„ì´ì½˜ ë° ì´ë¦„
        const iconEl = panel.querySelector('.info-type-icon');
        const nameEl = panel.querySelector('.info-type-name');
        if (iconEl) iconEl.textContent = info.icon;
        if (nameEl) nameEl.textContent = info.name;

        // ì• ë‹ˆë©”ì´ì…˜
        const animEl = document.getElementById('info-animation');
        if (animEl) {
            animEl.innerHTML = animationData[type] || '';
        }

        // ì„¤ëª…
        const descEl = panel.querySelector('.info-description');
        if (descEl) descEl.textContent = info.description;

        // ì‚¬ìš©ë²•
        const usageSection = document.getElementById('info-usage-section');
        const usageEl = document.getElementById('info-usage');
        if (usageEl && usageSection) {
            const usage = usageData[type];
            if (usage) {
                usageEl.textContent = usage;
                usageSection.style.display = 'block';
            } else {
                usageSection.style.display = 'none';
            }
        }

        // ì…ë ¥/ì¶œë ¥
        const inputsEl = document.getElementById('info-inputs');
        const outputsEl = document.getElementById('info-outputs');
        if (inputsEl) inputsEl.textContent = info.inputs;
        if (outputsEl) outputsEl.textContent = info.outputs;

        // ì§„ë¦¬í‘œ
        const truthTableContainer = document.getElementById('info-truth-table');
        if (truthTableContainer) {
            if (info.truthTable && info.truthTable.length > 0) {
                truthTableContainer.style.display = 'block';
                const table = truthTableContainer.querySelector('.truth-table');
                if (table) {
                    let html = '<thead><tr>';
                    const colCount = info.truthTable[0].length;
                    const headers = info.headers || (
                        colCount === 2 ? ['In', 'Out'] :
                            colCount === 3 ? ['A', 'B', 'Out'] :
                                colCount === 4 ? ['A', 'B', 'S', 'C'] :
                                    Array.from({ length: colCount }, (_, i) => `C${i}`)
                    );
                    headers.forEach(h => html += `<th>${h}</th>`);
                    html += '</tr></thead><tbody>';
                    info.truthTable.forEach(row => {
                        html += '<tr>';
                        row.forEach((cell, idx) => {
                            const isOutput = idx >= colCount - (colCount === 2 ? 1 : colCount === 3 ? 1 : 2);
                            const className = cell === '1' ? 'high' : 'low';
                            html += `<td class="${isOutput ? className : ''}">${cell}</td>`;
                        });
                        html += '</tr>';
                    });
                    html += '</tbody>';
                    table.innerHTML = html;
                }
            } else {
                truthTableContainer.style.display = 'none';
            }
        }

        // íŒ¨ë„ í‘œì‹œ
        panel.classList.remove('hidden');
    }

    hideTooltip() {
        // component-info-panel ìˆ¨ê¸°ê¸°
        const panel = document.getElementById('component-info-panel');
        if (panel) {
            panel.classList.add('hidden');
        }
    }

    // Position tooltip - ì´ì œ component-info-panelì´ ê³ ì • ìœ„ì¹˜ì´ë¯€ë¡œ í•„ìš” ì—†ìŒ
    positionTooltip(event) {
        // component-info-panelì€ CSSë¡œ ê³ ì • ìœ„ì¹˜ (ì¢Œì¸¡ ìƒë‹¨)
        // ë³„ë„ ìœ„ì¹˜ ì¡°ì • ë¶ˆí•„ìš”
    }

    // [Section 6] UI Handling
    toggleSidebar() {
        const toolbox = document.getElementById('toolbox') || document.querySelector('.sidebar');
        const workspace = document.getElementById('workspace');
        if (!toolbox || !workspace) return;

        toolbox.classList.toggle('collapsed');
        workspace.classList.toggle('collapsed');

        // bodyì—ë„ í´ë˜ìŠ¤ ì¶”ê°€í•˜ì—¬ ì„¤ëª…ì°½ ìœ„ì¹˜ ì¡°ì •
        document.body.classList.toggle('sidebar-collapsed', toolbox.classList.contains('collapsed'));

        // Update button arrow
        const btn = document.getElementById('btn-collapse');
        if (btn) {
            if (toolbox.classList.contains('collapsed')) {
                btn.innerHTML = 'â–¶';
            } else {
                btn.innerHTML = 'â—€';
            }
        }
    }

    // =========================================================
    // [Section 6.1] ì „ë¬¸ê°€ ëª¨ë“œ - íŒ¨í‚¤ì§€ ì‹œìŠ¤í…œ
    // =========================================================
    // NOTE: addPackage, createPackage í•¨ìˆ˜ëŠ” Section 3-2ì— ì •ì˜ë¨ (ì¤‘ë³µ ì œê±°ë¨)

    // ì‚¬ìš©ì íŒ¨í‚¤ì§€ ëª©ë¡ ì—…ë°ì´íŠ¸
    updateUserPackagesList() {
        const container = document.getElementById('user-packages');
        if (!container) return;

        const userPackages = JSON.parse(localStorage.getItem('userPackages') || '[]');

        container.innerHTML = userPackages.map((pkg, index) => `
            <button class="comp-btn package wide" onclick="sim.loadUserPackage(${index})">
                <div class="icon">ğŸ“¦</div>
                <span class="name">${pkg.name}</span>
            </button>
        `).join('');
    }

    // ì‚¬ìš©ì íŒ¨í‚¤ì§€ ë¡œë“œ
    loadUserPackage(index) {
        const userPackages = JSON.parse(localStorage.getItem('userPackages') || '[]');
        const pkg = userPackages[index];
        if (!pkg) return;

        const baseX = 200 + Math.random() * 100;
        const baseY = 150 + Math.random() * 100;

        pkg.components.forEach(comp => {
            this.addModule(comp.type, baseX + comp.x - pkg.components[0].x, baseY + comp.y - pkg.components[0].y);
        });

        this.showToast(`"${pkg.name}" íŒ¨í‚¤ì§€ ë¡œë“œë¨`, 'success');
    }

    // =========================================================
    // [Section 6.2] ì‹œë®¬ë ˆì´ì…˜ ì†ë„ ì œì–´
    // =========================================================

    // ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ì¤‘ ë ˆì´ë¸”ë§Œ ì—…ë°ì´íŠ¸ (í† ìŠ¤íŠ¸ ì—†ìŒ)
    updateSpeedLabel(speed) {
        this.simulationSpeed = Math.max(0.1, Math.min(10, speed));
        const label = document.getElementById('speed-value');
        if (label) label.textContent = `${this.simulationSpeed.toFixed(1)}x`;
    }

    // ì†ë„ ì„¤ì • ì™„ë£Œ (ìŠ¬ë¼ì´ë”ì—ì„œ ì† ë—„ ë•Œ í˜¸ì¶œ)
    setSimulationSpeed(speed, showNotification = false) {
        this.simulationSpeed = Math.max(0.1, Math.min(10, speed));
        const label = document.getElementById('speed-value');
        if (label) label.textContent = `${this.simulationSpeed.toFixed(1)}x`;

        if (showNotification) {
            this.showToast(`ì‹œë®¬ë ˆì´ì…˜ ì†ë„: ${this.simulationSpeed.toFixed(1)}x`, 'info');
        }
    }

    // =========================================================
    // [Section 7] í¸ì˜ ê¸°ëŠ¥ (LED ìƒ‰ìƒ, ì •ë ¬, íšŒì „, ë³µì œ, ì‚­ì œ)
    // =========================================================

    // ê·¸ë¦¬ë“œ ìŠ¤ëƒ… í† ê¸€
    toggleGridSnap() {
        this.gridSnap = !this.gridSnap;
        const btn = document.getElementById('btn-grid-snap');
        if (btn) btn.classList.toggle('active', this.gridSnap);
        this.showToast(this.gridSnap ? 'ê·¸ë¦¬ë“œ ìŠ¤ëƒ… ON' : 'ê·¸ë¦¬ë“œ ìŠ¤ëƒ… OFF', 'info');
    }

    // ì „ì„  ì—°ê²° ëª¨ë“œ í† ê¸€ (í•€ ì§ì ‘ vs ê²©ì ê¸°ë°˜)
    toggleWireMode() {
        this.wireMode = this.wireMode === 'pin' ? 'grid' : 'pin';
        const btn = document.getElementById('btn-wire-mode');
        if (btn) {
            btn.textContent = this.wireMode === 'pin' ? 'ğŸ”Œ í•€' : 'ğŸ“ ê²©ì';
        }
        this.showToast(this.wireMode === 'pin' ? 'í•€ ì§ì ‘ ì—°ê²° ëª¨ë“œ' : 'ê²©ì ê¸°ì¤€ ì—°ê²° ëª¨ë“œ', 'info');
    }

    // ì „ì²´ ì„ íƒ (Ctrl+A)
    selectAll() {
        this.clearSelection();
        this.components.forEach(comp => this.selectComponent(comp, true));
        this.showToast(`${this.components.length}ê°œ ì „ì²´ ì„ íƒë¨`, 'info');
        this.updateStatusBar();
    }

    // ìˆ˜í‰ ê· ë“± ë°°ì¹˜
    distributeHorizontal() {
        if (this.selectedComponents.length < 3) {
            this.showToast('ê· ë“± ë°°ì¹˜í•˜ë ¤ë©´ 3ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        // X ì¢Œí‘œë¡œ ì •ë ¬
        const sorted = [...this.selectedComponents].sort((a, b) =>
            parseFloat(a.style.left) - parseFloat(b.style.left)
        );

        const minX = parseFloat(sorted[0].style.left);
        const maxX = parseFloat(sorted[sorted.length - 1].style.left);
        const spacing = (maxX - minX) / (sorted.length - 1);

        sorted.forEach((comp, i) => {
            comp.style.left = (minX + i * spacing) + 'px';
        });

        this.redrawWires();
        this.saveState();
        this.showToast('ìˆ˜í‰ ê· ë“± ë°°ì¹˜ ì™„ë£Œ', 'success');
    }

    // ìˆ˜ì§ ê· ë“± ë°°ì¹˜
    distributeVertical() {
        if (this.selectedComponents.length < 3) {
            this.showToast('ê· ë“± ë°°ì¹˜í•˜ë ¤ë©´ 3ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        // Y ì¢Œí‘œë¡œ ì •ë ¬
        const sorted = [...this.selectedComponents].sort((a, b) =>
            parseFloat(a.style.top) - parseFloat(b.style.top)
        );

        const minY = parseFloat(sorted[0].style.top);
        const maxY = parseFloat(sorted[sorted.length - 1].style.top);
        const spacing = (maxY - minY) / (sorted.length - 1);

        sorted.forEach((comp, i) => {
            comp.style.top = (minY + i * spacing) + 'px';
        });

        this.redrawWires();
        this.saveState();
        this.showToast('ìˆ˜ì§ ê· ë“± ë°°ì¹˜ ì™„ë£Œ', 'success');
    }

    // ìˆ˜í‰ ë’¤ì§‘ê¸° (ì¢Œìš° ë°˜ì „)
    flipHorizontal() {
        if (this.selectedComponents.length < 2) return;

        let minX = Infinity, maxX = -Infinity;
        this.selectedComponents.forEach(comp => {
            const x = parseFloat(comp.style.left);
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
        });

        const centerX = (minX + maxX) / 2;
        this.selectedComponents.forEach(comp => {
            const x = parseFloat(comp.style.left);
            comp.style.left = (2 * centerX - x) + 'px';
        });

        this.redrawWires();
        this.saveState();
        this.showToast('ì¢Œìš° ë°˜ì „ ì™„ë£Œ', 'success');
    }

    // ìˆ˜ì§ ë’¤ì§‘ê¸° (ìƒí•˜ ë°˜ì „)
    flipVertical() {
        if (this.selectedComponents.length < 2) return;

        let minY = Infinity, maxY = -Infinity;
        this.selectedComponents.forEach(comp => {
            const y = parseFloat(comp.style.top);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        });

        const centerY = (minY + maxY) / 2;
        this.selectedComponents.forEach(comp => {
            const y = parseFloat(comp.style.top);
            comp.style.top = (2 * centerY - y) + 'px';
        });

        this.redrawWires();
        this.saveState();
        this.showToast('ìƒí•˜ ë°˜ì „ ì™„ë£Œ', 'success');
    }

    // ì„ íƒ ì ê¸ˆ (ì´ë™ ë°©ì§€)
    lockSelection() {
        this.selectedComponents.forEach(comp => {
            comp.classList.toggle('locked');
        });
        this.showToast('ì„ íƒ í•­ëª© ì ê¸ˆ í† ê¸€', 'info');
    }

    // LED ìƒ‰ìƒ ë³€ê²½
    setLEDColor(color) {
        const validColors = ['red', 'green', 'blue', 'yellow', 'white'];
        if (!validColors.includes(color)) return;

        this.selectedComponents.forEach(comp => {
            if (comp.getAttribute('data-type') === 'LED') {
                comp.setAttribute('data-color', color);
                this.showToast(`LED ìƒ‰ìƒ: ${color}`, 'info');
            }
        });
        this.hideContextMenu();
        this.saveState();
    }

    // ìˆ˜í‰ ì •ë ¬ (ì„ íƒëœ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ Yì¢Œí‘œë¥¼ í‰ê· ìœ¼ë¡œ ë§ì¶¤)
    alignSelectedHorizontal() {
        if (this.selectedComponents.length < 2) {
            this.showToast('ì •ë ¬í•  ì»´í¬ë„ŒíŠ¸ë¥¼ 2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        let sumY = 0;
        this.selectedComponents.forEach(comp => {
            sumY += parseInt(comp.style.top) || 0;
        });
        const avgY = Math.round(sumY / this.selectedComponents.length);

        this.selectedComponents.forEach(comp => {
            comp.style.top = avgY + 'px';
        });

        this.redrawWires();
        this.hideContextMenu();
        this.saveState();
        this.showToast('ìˆ˜í‰ ì •ë ¬ ì™„ë£Œ', 'success');
    }

    // ìˆ˜ì§ ì •ë ¬ (ì„ íƒëœ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ Xì¢Œí‘œë¥¼ í‰ê· ìœ¼ë¡œ ë§ì¶¤)
    alignSelectedVertical() {
        if (this.selectedComponents.length < 2) {
            this.showToast('ì •ë ¬í•  ì»´í¬ë„ŒíŠ¸ë¥¼ 2ê°œ ì´ìƒ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        let sumX = 0;
        this.selectedComponents.forEach(comp => {
            sumX += parseInt(comp.style.left) || 0;
        });
        const avgX = Math.round(sumX / this.selectedComponents.length);

        this.selectedComponents.forEach(comp => {
            comp.style.left = avgX + 'px';
        });

        this.redrawWires();
        this.hideContextMenu();
        this.saveState();
        this.showToast('ìˆ˜ì§ ì •ë ¬ ì™„ë£Œ', 'success');
    }

    // ì»´í¬ë„ŒíŠ¸ íšŒì „ (90ë„ì”©)
    rotateSelected() {
        this.selectedComponents.forEach(comp => {
            const currentRotation = parseInt(comp.getAttribute('data-rotation') || '0');
            const newRotation = (currentRotation + 90) % 360;
            comp.setAttribute('data-rotation', newRotation);
            comp.style.transform = `rotate(${newRotation}deg)`;
        });

        this.redrawWires();
        this.hideContextMenu();
        this.saveState();
        this.showToast('íšŒì „ ì™„ë£Œ', 'success');
    }

    // ë³µì œ ê¸°ëŠ¥
    duplicateSelection() {
        if (this.selectedComponents.length === 0) {
            this.showToast('ë³µì œí•  ì»´í¬ë„ŒíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        const newComponents = [];
        const offset = 30; // ë³µì œ ì˜¤í”„ì…‹

        this.selectedComponents.forEach(comp => {
            const type = comp.getAttribute('data-type');
            const x = (parseInt(comp.style.left) || 0) + offset;
            const y = (parseInt(comp.style.top) || 0) + offset;

            const newComp = this.addModule(type, x, y);
            if (newComp) {
                // ì†ì„± ë³µì‚¬
                const color = comp.getAttribute('data-color');
                if (color) newComp.setAttribute('data-color', color);
                newComponents.push(newComp);
            }
        });

        // ìƒˆ ì»´í¬ë„ŒíŠ¸ ì„ íƒ
        this.clearSelection();
        newComponents.forEach(comp => this.selectComponent(comp, true));

        this.hideContextMenu();
        this.saveState();
        this.showToast(`${newComponents.length}ê°œ ë³µì œë¨`, 'success');
    }

    // ë³µì‚¬
    copySelection() {
        if (this.selectedComponents.length === 0) {
            this.showToast('ë³µì‚¬í•  ì»´í¬ë„ŒíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        this.clipboard = this.selectedComponents.map(comp => ({
            type: comp.getAttribute('data-type'),
            x: parseInt(comp.style.left) || 0,
            y: parseInt(comp.style.top) || 0,
            color: comp.getAttribute('data-color'),
            rotation: comp.getAttribute('data-rotation')
        }));

        this.hideContextMenu();
        this.showToast(`${this.clipboard.length}ê°œ ë³µì‚¬ë¨`, 'success');
    }

    // ë¶™ì—¬ë„£ê¸°
    pasteFromClipboard() {
        if (!this.clipboard || this.clipboard.length === 0) {
            this.showToast('ë¶™ì—¬ë„£ì„ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤', 'warning');
            return;
        }

        const offset = 40;
        const newComponents = [];

        this.clipboard.forEach(item => {
            const newComp = this.addModule(item.type, item.x + offset, item.y + offset);
            if (newComp) {
                if (item.color) newComp.setAttribute('data-color', item.color);
                if (item.rotation) {
                    newComp.setAttribute('data-rotation', item.rotation);
                    newComp.style.transform = `rotate(${item.rotation}deg)`;
                }
                newComponents.push(newComp);
            }
        });

        this.clearSelection();
        newComponents.forEach(comp => this.selectComponent(comp, true));

        this.hideContextMenu();
        this.saveState();
        this.showToast(`${newComponents.length}ê°œ ë¶™ì—¬ë„£ê¸°ë¨`, 'success');
    }

    // ì‚­ì œ
    deleteSelected() {
        if (this.selectedComponents.length === 0) {
            this.showToast('ì‚­ì œí•  ì»´í¬ë„ŒíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        const count = this.selectedComponents.length;

        // ì—°ê²°ëœ ì™€ì´ì–´ ì‚­ì œ
        this.selectedComponents.forEach(comp => {
            const pins = comp.querySelectorAll('.pin');
            pins.forEach(pin => {
                const pinId = pin.id;
                this.wires = this.wires.filter(w => {
                    if (w.from === pinId || w.to === pinId) {
                        if (w.line && w.line.parentNode) {
                            w.line.parentNode.removeChild(w.line);
                        }
                        return false;
                    }
                    return true;
                });
            });

            // ì»´í¬ë„ŒíŠ¸ ì‚­ì œ
            if (comp.parentNode) {
                comp.parentNode.removeChild(comp);
            }
        });

        this.selectedComponents = [];
        this.hideContextMenu();
        this.updateStatusBar();
        this.saveState();
        this.showToast(`${count}ê°œ ì‚­ì œë¨`, 'success');
    }

    // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ (LED ì˜µì…˜ ì¡°ê±´ë¶€ í‘œì‹œ)
    showContextMenu(x, y) {
        if (!this.contextMenu) return;

        // LED ìƒ‰ìƒ ì˜µì…˜ í‘œì‹œ ì—¬ë¶€
        const hasLED = this.selectedComponents.some(comp =>
            comp.getAttribute('data-type') === 'LED'
        );

        this.contextMenu.querySelectorAll('.ctx-led-only').forEach(el => {
            el.style.display = hasLED ? '' : 'none';
        });

        this.contextMenu.style.left = x + 'px';
        this.contextMenu.style.top = y + 'px';
        this.contextMenu.style.display = 'block';
    }

    // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°
    hideContextMenu() {
        if (this.contextMenu) {
            this.contextMenu.style.display = 'none';
        }
    }
}

// ===================================
// [Oscilloscope Class]
// ===================================
class Oscilloscope {
    constructor(sim) {
        this.sim = sim;
        this.canvas = document.getElementById('oscilloscope-canvas');
        this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
        this.history = []; // { time: 0, signals: { id: val, ... } }
        this.maxHistory = 500;

        if (this.canvas) {
            this.resize();
            window.addEventListener('resize', () => this.resize());
        }
    }

    resize() {
        if (!this.canvas || !this.canvas.parentElement) return;
        if (this.canvas.parentElement.style.display === 'none') return;
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height - 25; // header height
    }

    update() {
        if (!this.canvas || !this.canvas.parentElement) return;
        if (this.canvas.parentElement.style.display === 'none') return;

        // Collect Output Signals (LEDs and Final Outputs)
        const signalSnapshot = {};
        this.sim.components.forEach(comp => {
            const type = comp.getAttribute('data-type');
            const val = comp.getAttribute('data-value') === '1' ? 1 : 0;
            if (type === 'LED' || type === 'SWITCH' || type === 'CLOCK' || type === 'PORT_OUT') {
                signalSnapshot[comp.id] = val;
            }
        });

        this.history.push(signalSnapshot);
        if (this.history.length > this.maxHistory) this.history.shift();
    }

    draw() {
        if (!this.canvas || !this.ctx || !this.canvas.parentElement) return;
        if (this.canvas.parentElement.style.display === 'none') return;

        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        ctx.clearRect(0, 0, w, h);

        const signals = Object.keys(this.history[0] || {});
        if (signals.length === 0) return;

        const rowHeight = h / signals.length;
        const stepX = w / this.maxHistory;

        signals.forEach((id, index) => {
            const yBase = index * rowHeight + rowHeight * 0.8;
            const amplitude = rowHeight * 0.6;

            ctx.beginPath();
            ctx.strokeStyle = `hsl(${index * 60}, 70%, 50%)`;
            ctx.lineWidth = 2;

            ctx.fillStyle = "#aaa";
            ctx.font = "10px monospace";
            ctx.fillText(id.substr(0, 8), 5, yBase - amplitude - 5);

            for (let i = 0; i < this.history.length; i++) {
                const val = this.history[i][id];
                const x = i * stepX;
                const y = yBase - (val * amplitude);

                if (i === 0) ctx.moveTo(x, y);
                else {
                    const prevVal = this.history[i - 1][id];
                    const prevY = yBase - (prevVal * amplitude);
                    ctx.lineTo(x, prevY);
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        });
    }
}

// ì‹œë®¬ë ˆì´í„° ì‹¤í–‰
window.sim = new CircuitSimulator();